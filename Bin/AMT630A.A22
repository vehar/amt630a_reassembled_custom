;:----------------- AMT630A firmware for 3.5" TFT screen
;------------------
;copyright 1/2018 martin korth (nocash)
;------------------
.x51_style_z80   ;want 8031/8051 code in Z80/80x86-style syntax
;note: this asm syntax can be assembled using no$x51
;------------------

;------------------
;VERSION  'XDD_MT_630A_35D_LD035H3_DX_3KEY_151022_LOGO'
;CUSTOMER 'Customer:MT_35D'
;DATE     'Time:Mar 07 2016'
;---
;VERSION  'GK_SK_630A_43D_DX_3KEY_170911'
;CUSTOMER 'Customer:SK_43D'
;DATE     'Time:Sep 11 2017'
;------------------
with_infrared   equ 1   ;implement functions (though they are yet unused in GUI)
with_keypad_irq equ 1
;------------------
flash_settings_1_addr_div_100h equ 01e0h  ;aka 01E000h
flash_settings_2_addr_div_100h equ 01f0h  ;aka 01F000h
iolist_endcode equ 00h  ;end
;------------------
;:----------------- XRAM
;------------------
.ram   ;XRAM (via MOVX opcode)
org  0
;xram_scratch_byte       db 0
;------------------
org  100h
xram_initial_hw_regs: defs 500h
xram_initial_spi_regs: defs 40h
 defs 40h
xram_initial_sfr_regs: defs 80h
;...
;------------------ Settings (from FLASH addr E000h/F000h)
org 700h  ;last 100h bytes of 2K xram
xram_settings_start:
xram_sett_id_5Ah     db 0 ;Settings Start ID (5Ah)
xram_sett_backlight  db 0 ;Settings Backlight
xram_sett_brightness db 0 ;Settings Brightness
xram_sett_contrast   db 0 ;Settings Contrast
xram_sett_saturation db 0 ;Settings Saturation (aka Mono/Color)
xram_sett_tint       db 0 ;Settings Tint (aka Hue)
xram_sett_volume     db 0 ;Settings Volume (done here via PWM1)
xram_sett_ratio      db 0 ;Settings Mode/Ratio (16:9 or 4:3)
xram_sett_no_signal  db 0 ;Settings NoSignal (STANDBY,BLUE,BLUE+SNOW,BLACK+SNOW)
xram_sett_input      db 0 ;Settings Input (aka SelSource)
xram_sett_xyflip     db 0
xram_sett_keypadtype db 0 ;Settings Keypad Type (eg. U_3KEY)
xram_sett_panel_type db 0 ;Settings Panel Type (eg. TIANMA 320x240)
xram_sett_rgb_ramps  db 0
xram_sett_yuv_consts db 0
xram_sett_pal_ntsc   db 0
xram_sett_allow_c64  db 0
xram_sett_tianma_r0f db 0
;xram_sett_ir        db 0 ;Settings InfraRed (blah, there are GUI functions for changing this setting, but the setting isn't used elsewhere for actual IR transfers)
xram_reserved_sys:   defs 40h-($-xram_settings_start)
xram_sett_mfloor_num_floors_solved_msb db 0
xram_sett_mfloor_num_floors_solved_lsb db 0
xram_reserved_games: defs 7eh-($-xram_settings_start)
xram_sett_id_A5h     db 0 ;Settings End ID (A5h)
xram_sett_chksum     db 0 ;Settings Xor Checksum
xram_settings_end:
xram_settings_size equ $-xram_settings_start
;------------------
xram_curr_input                   db 0   ;-
xram_palntsc_same_counter         db 0   ;-lcd_same_signal_counter
xram_keypad_was_read     db 0       ;keyboard (set to 01h upon first keyboard reading?) (can be 02h in newer firmware!?!)
xram_keypad_whatever     db 0       ;keyboard key.no? key.repeat.flags?   ... or IR input?
;---
xram_irq_coarse_offhold        db 0   ;... some 250-step offhold in irq handler
xram_old_AV_stat_signal_detect db 0   ;old lower 4bit of "IO_AV_stat_signal_detect" ;\
xram_irq_artifacts_offhold     db 0   ;... some 20-step offhold in irq handler     ;/
xram_old_AV_stat_detect_2      db 0   ;mode? fixed FFh ?                         ;\
xram_irq_sharpness_offhold     db 0   ;... some 10-step offhold in irq handler  ;/
xram_irq_sensitivity_offhold   db 0   ;... some 100-step detect offhold
;---
xram_irq_vectors: defs 2*13  ;thirteen vectors (0003h..0063h)
                  defs 2*3   ;three extra vectors (006Bh..007Bh) -- if any there?
;---
;with_keypad_irq
num_keypad_readings equ 3
xram_analog_keypad_index   db 0
xram_analog_keypad_values: defs 2*num_keypad_readings
;---
xram_new_detected_video db 0   ;00h or 04h or FFh
xram_lcdspi_type    db 0                ;\
 lcdspi_NV3035C equ 0                   ;
 lcdspi_UNKNOWN equ 0ffh                ;/
;---
xram_end:
.errif $>800h
 defs 800h-$  ;more xram (unused by firmware) (total 2Kbyte)
;---
 defs 01800h  ;mirror of CODE/SPIFLASH addr 800h..1FFFh (read only) (not so useful... unless it can be bank-switched to FLASH address above 64Kbyte space?)
 defs 01000h  ;unknown (hardware status regs ?)         (read only)
 defs 0cb00h  ;unused (FFh-filled)                      (read only)
.errif $-0fb00h
;------------------
;I/O ports at FB00h..FFFFh (via MOVX)...
;---
IO_OSD_bgmap_addr_lsb     db 0   ;     ;VRAM addr.lsb (xloc) (auto-incrementing on data writes?)
IO_OSD_bgmap_data_lsb     db 0   ;
IO_OSD_font_addr_lsb      db 0   ;     ;ADDR for manual vram upload? (index*factor?)
IO_OSD_font_data_lsb      db 0   ;     ;DATA_MSB for manual vram upload?
IO_OSD_font_data_msb      db 0   ;     ;DATA_LSB for manual vram upload?
IO_OSD_window_enable_bits db 0   ;flags  (bit0..4=enable window 0..4, used other bits=?)  (bit6:hides windows,TEXT ON/OFF) (bit7:bitmap,BITMAP ON/OFF)
IO_OSD_misc_transp_enable db 0   ;   IO_OSD_      ... upper2bit=semitrans.ctrl, other6bit=?
;---
IO_OSD_window_0_size_x    db 0   ;     ;bit7:NOT R/W
IO_OSD_window_0_size_y    db 0   ;     ;bit6-7:NOT R/W
IO_OSD_window_0_xyloc_msb db 0   ;     ;bit7:NOT R/W ;msb's of 2x11bit (maybe xyloc?) (and two extra bits)
IO_OSD_window_0_xloc_lsb  db 0   ;       ;lsb's of 11bit   (maybe xloc?)
IO_OSD_window_0_yloc_lsb  db 0   ;       ;lsb's of 11bit   (maybe yloc?)
;(IO_OSD_window_0_vramaddr_lsb)  <-- NONE SUCH (win0 addr=fixed=00h?)
;---
IO_OSD_bright_transp_level   db 0   ;upper3bit=brightness, lower3bit=transparency, middle2bit=?
IO_OSD_bgmap_addr_msb        db 0   ;  ;bit1-7:NOT R/W    ;VRAM addr.lsb (xloc) (need manual increment on LSB-carry-outs?)
IO_OSD_bgmap_data_msb        db 0   ;  ;bit2-7:NOT R/W
IO_OSD_font_addr_msb         db 0   ;  ;bit4-7:NOT R/W
IO_OSD_bgmap_data_attr       db 0   ;  ;bit7:NOT R/W
IO_OSD_bitmap_start_lsb      db 0   ;   IO_OSD_      ... ? (always set to 28h)  (num TEXT chars, at 1C0h and up) (remaining chars are BITMAP chars) (msbs in FB70h)
;---
IO_OSD_window_1_size_x       db 0   ;  ;bit7:NOT R/W
IO_OSD_window_1_size_y       db 0   ;  ;bit6-7:NOT R/W
IO_OSD_window_1_xyloc_msb    db 0   ;     ;MSBs for xloc,yloc,vramaddr (plus 1bit unknown)
IO_OSD_window_1_xloc_lsb     db 0   ;
IO_OSD_window_1_yloc_lsb     db 0   ;
IO_OSD_window_1_vramaddr_lsb db 0   ;
;---
IO_OSD_window_2_size_x       db 0   ;  ;bit7:NOT R/W
IO_OSD_window_2_size_y       db 0   ;  ;bit6-7:NOT R/W
IO_OSD_window_2_xyloc_msb    db 0   ;
IO_OSD_window_2_xloc_lsb     db 0   ;
IO_OSD_window_2_yloc_lsb     db 0   ;
IO_OSD_window_2_vramaddr_lsb db 0   ;    ;(MSB is in FB1Ah.bit7)
;---
IO_OSD_window_3_size_x       db 0   ;  ;bit7:NOT R/W
IO_OSD_window_3_size_y       db 0   ;  ;bit6-7:NOT R/W
IO_OSD_window_3_xyloc_msb    db 0   ;
IO_OSD_window_3_xloc_lsb     db 0   ;
IO_OSD_window_3_yloc_lsb     db 0   ;
IO_OSD_window_3_vramaddr_lsb db 0   ;
;---
IO_OSD_window_4_size_x       db 0   ;  ;bit7:NOT R/W
IO_OSD_window_4_size_y       db 0   ;  ;bit6-7:NOT R/W
IO_OSD_window_4_xyloc_msb    db 0   ;
IO_OSD_window_4_xloc_lsb     db 0   ;
IO_OSD_window_4_yloc_lsb     db 0   ;
IO_OSD_window_4_vramaddr_lsb db 0   ;
;---
                             db 0   ;  (unused)    ;bit7:NOT R/W
IO_OSD_window_0_vscale_upper db 0   ;\(3 bytes) (00h- or FFh-filled)  ;<-- vscale each line in for 24line chars ? (FB2Bh.bit0=upper line)
IO_OSD_window_0_vscale_upmid db 0   ;
IO_OSD_window_0_vscale_lomid db 0   ;/
IO_OSD_window_0_vscale_lower db 0   ;-extra for height=32 (unused by firmware)
IO_OSD_window_0_hscale_left  db 0   ;\(3 bytes) (00h- or FFh-filled)  ;<-- hscale each pix in for 24pix chars ?   (FB2Fh.bit0=left pix)
IO_OSD_window_0_hscale_mid   db 0   ;
IO_OSD_window_0_hscale_right db 0   ;/
IO_OSD_window_0_scale        db 0   ;\   ;<-- ;bit4-7:NOT R/W
IO_OSD_window_1_and_2_scale  db 0   ; txt.scale (2x2bit, for lsbs=ScaleX and msbs=ScaleY, per window?)
IO_OSD_window_3_and_4_scale  db 0   ;/
IO_OSD_bitmap_transp_misc    db 0   ;   fixed (00h)  ;changes to bit3,5 affect window positions (bit3=SOMEpixX, bit5=1pixY) (bit4:bitmap TRANSP color0?)    ;bit6-7:NOT R/W
IO_OSD_bitmap_colors:  defs 32 ;sixteen words (20h bytes) (used only by an UNUSED function) maybe 16-color bitmap palette?  ;\EVEN ADDRESSES: bit4-7:NOT R/W
;IO_OSD_color_0   ;color 0 is fixed? (transparent) (just shows BLUE NO SIGNAL background)                       ;
IO_OSD_color_1_msb      db 0   ;fixed (00h)  ;\00h,0Fh red                                                       ;
IO_OSD_color_1_lsb      db 0   ;fixed (0Fh)  ;/                                                                  ;
IO_OSD_color_2_msb      db 0   ;fixed (00h)  ;\00h,F0h green  ... maybe 4:4:4 RGB colors?                        ;
IO_OSD_color_2_lsb      db 0   ;fixed (F0h)  ;/                                                                  ;
IO_OSD_color_3_msb      db 0   ;fixed (0Fh)  ;\0Fh,00h blue (slightly brighter than BLUE NO SIGNAL background)   ;
IO_OSD_color_3_lsb      db 0   ;fixed (00h)  ;/                                                                  ;
IO_OSD_color_4_msb      db 0   ;fixed (00h)  ;\00h,FFh yellow (r+g)                                              ;
IO_OSD_color_4_lsb      db 0   ;fixed (FFh)  ;/                                                                  ;
IO_OSD_color_5_msb      db 0   ;fixed (0Fh)  ;\0Fh,F0h cyan (g+b)                                                ;
IO_OSD_color_5_lsb      db 0   ;fixed (F0h)  ;/                                                                  ;
IO_OSD_color_6_msb      db 0   ;fixed (0Fh)  ;\0Fh,FFh white (r+g+b)                                             ;
IO_OSD_color_6_lsb      db 0   ;fixed (FFh)  ;/                                                                  ;
;IO_OSD_color_7   ;color 7 is fixed? (black)                                                                    ;/
IO_OSD_whatever_FB62h   db 0   ;whatever (bit0 cleared by firmware)
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
IO_OSD_bitmap_start_msb db 0   ;fixed (00h) ;num TEXT chars (msbs of FB11h)  ;bit2-7:NOT R/W
     db 0     ;   (unused)      ;-bit1-7:NOT R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
     db 0     ;   (unused)      ;-fully R/W
IO_OSD_char_xsiz     db 0     ;\character x/y size in pixels  ;<-- lower5bit (upper3bit=?)  ;bit5-7:NOT R/W
IO_OSD_char_ysiz     db 0     ;/(xsiz max 24pix?)             ;<-- lower6bit (upper2bit=?)  ;bit6-7:NOT R/W
IO_OSD_xyflip        db 0     ;-(used by unused functions)  bit4:TileXflip, bit5:MapXflip, bit6:TileYflip, bit7:MapYflip, lower4bit=?
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-bit4-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-bit4-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit6-7:NOT R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
     db 0     ;   (unused)      ;-bit7:NOT R/W
IO_OSD_screen_position     db 0     ;   fixed (00h)    ;changes affect window positions?  ;bit1=jitters!   ;bit4-7:NOT R/W
;---
 defs 3Ch  ;unused (FFh-filled) ;NOT RW        ;FB8Ah..FBFFh: NOT R/W (uh, but FBC6h/FBC7h is written by firmware?)
IO_OSD_bugged_color_lsb db 0    ;\color 4:4:4 ? bugged?
IO_OSD_bugged_color_msb db 0    ;/
 defs 38h  ;unused (FFh-filled) ;NOT RW
.errif $-0fc00h
;--- --- --- maybe LCD/VIDEO... and/or... OSD/VIDEO...
IO_LCD_color_swap       db 0     ;fixed (05h)   ;bit0,1,2,3: color swap for AV and OSD (maybe LCD databus mode?)  ;upper4bit no visible effect on PAL+PAL60 image
                        db 0     ;   (unused)   ;whatever, no effect on PAL picture?
                        db 0     ;   (unused)   ;bit0,1,2:kills AV image  ;bit3-7: NOT R/W
                        defs 44h ;   (unused)   ;whatever, <-- no visible effect on PAL+PAL60 picture?
                                ;FC09h.bit5-7:NOT RW
                                ;FC0Dh.bit6-7:NOT RW
                                ;FC0Fh.bit6-7:NOT RW
                                ;FC11h:NOT RW ;<-- unused (FFh-filled)
                                ;FC13h.bit4-7:NOT RW  ;-
                                ;FC19h.bit3-7:NOT RW  ;\
                                ;FC1Bh.bit3-7:NOT RW  ;
                                ;FC1Dh.bit3-7:NOT RW  ;
                                ;FC1Fh.bit3-7:NOT RW  ;
                                ;FC21h.bit3-7:NOT RW  ;
                                ;FC23h.bit3-7:NOT RW  ;
                                ;FC25h.bit3-7:NOT RW  ;
                                ;FC27h.bit3-7:NOT RW  ;
                                ;FC29h.bit3-7:NOT RW  ;
                                ;FC2Bh.bit3-7:NOT RW  ;
                                ;FC2Dh.bit3-7:NOT RW  ;
                                ;FC2Fh.bit3-7:NOT RW  ;/
                                ;FC31h.bit2-7:NOT RW  ;\
                                ;FC33h.bit2-7:NOT RW  ;/
                                ;FC44h.bit4-7:NOT RW  ;-
                                ;FC46h.bit6-7:NOT RW  ;-
 defs 49h   ;unused (FFh-filled)      ;NOT R/W
;---
IO_VIDEO_control                  db 0  ;fixed (02h)   ;on PAL50: bit0=VerticalScale(forceNTSCresolution?), bit5:BLUEinsteadOfRED?, bit7:MinorEffectOnRightScreenEdge ----  on PAL60:bit5=BlueColors, other bits no effect for PAL60
;--- below FC91h..FCB6h resembles FCBDh..FCE2h
;below FC91h..FCBBh DON'T affect PAL (affect NTSC only, and do also affect PAL60)
IO_60HZ_control_lsb               db 0  ;fixed (01h)   ;     ;bit1:MoveWholeImageCa.80pixLEFT, bit3:AV_OFF/BLACK, bit5:AV_WeirdDiagonalStripeStretch(ignoreHsyncOrSo), bit6:ContrastOnPAL60colorError
IO_60HZ_control_mid               db 0  ;initially(00h);      <-- bit4 modified later on (alongsides FCBDh)   ;bit0:EdgyDiagonalPAL60colorError, bit3:AV_MOSTLY_BLACK_except_right_edge_and_lowerleft_corner
IO_60HZ_control_msb               db 0  ;fixed (00h)   ;/       ;bit2:MoveWholeImageCa.80pixRIGHT, bit3:ContrastOnPAL60colorError
IO_60HZ_internal_unused1          db 0  ;   (unused)
IO_60HZ_internal_unused2          db 0  ;   (unused)
IO_60HZ_ratio_whatever_A_lsb      db 0  ;set to ONE of six fixed values (61h,7Eh,5Bh,5Bh,5Bh,5Bh)  ;\screen ratio? no visible effect when toggling bits here
IO_60HZ_ratio_whatever_A_msb      db 0  ;set to ONE of six fixed values (08h,08h,03h,03h,03h,03h)  ;/(ie. 16:9 or 4:3 or DUMMY values?)
IO_60HZ_15khz_lsb                 db 0  ;fixed (C8h)   ;\03C8h (968 decimal) ;ca.(hres*3)?        ;PAL60: bit3 fixes missed-PAL60-scanlines (still PAL-color is wrong)
IO_60HZ_15khz_msb                 db 0  ;fixed (03h)   ;/
IO_60HZ_15khz_div2_lsb            db 0  ;fixed (E3h)   ;\01E3h (483 decimal) ;ca.(vres*2)?        ;PAL60: bit2 fixes missed-PAL60-scanlines (still PAL-color is wrong)
IO_60HZ_15khz_div2_msb            db 0  ;fixed (01h)   ;/               ;or, roughly, 3C8h/2 ?
IO_60HZ_xloc_av_osd_lsb           db 0  ;fixed (00h)   ;\hpos AV+OSD
IO_60HZ_xloc_av_osd_msb           db 0  ;fixed (00h)   ;/
IO_60HZ_xloc_osd_lsb              db 0  ;fixed (44h)   ;\hpos OSD
IO_60HZ_xloc_osd_msb              db 0  ;fixed (00h)   ;/
IO_60HZ_xloc_av_lsb               db 0  ;fixed (43h)   ;\hpos AV
IO_60HZ_xloc_av_msb               db 0  ;fixed (00h)   ;/
IO_60HZ_xcrop_end_av_lsb          db 0  ;fixed (8Ah)   ;\hcrop.end AV
IO_60HZ_xcrop_end_av_msb          db 0  ;fixed (01h)   ;/
IO_60HZ_yloc_av_osd_lsb           db 0  ;fixed (07h)   ;\vpos AV+OSD
IO_60HZ_yloc_av_osd_msb           db 0  ;fixed (00h)   ;/
IO_60HZ_yloc_osd_lsb              db 0  ;fixed (09h)   ;\vpos OSD
IO_60HZ_yloc_osd_msb              db 0  ;fixed (00h)   ;/
IO_60HZ_ycrop_upper_av_lsb        db 0  ;fixed (10h)   ;\vcrop.upper AV
IO_60HZ_ycrop_upper_av_msb        db 0  ;fixed (00h)   ;/
IO_60HZ_heavy_flimmer_lsb         db 0  ;fixed (10h)   ;\                            bit3,5-7: PAL60 flickersTheWrongColors
IO_60HZ_heavy_flimmer_msb         db 0  ;fixed (01h)   ;/                                      PAL60 flickers!!!
IO_60HZ_ratio_xloc_av_8bit        db 0  ;set to ONE of six fixed values (10h,10h,1Dh,1Dh,1Dh,1Dh)  ;\     hpos AV (with GARBAGE after scanline.end)
IO_60HZ_ratio_whatever_B_lsb      db 0  ;set to ONE of six fixed values (00h,00h,09h,09h,09h,09h)  ;  ;-no visible effect when toggling bits
IO_60HZ_ratio_whatever_B_msb      db 0  ;set to ONE of six fixed values (00h,00h,00h,00h,00h,00h)  ;  ;-no visible effect when toggling bits
IO_60HZ_ratio_ycrop_upper_av_8bit db 0  ;set to ONE of six fixed values (00h,00h,00h,00h,00h,00h)  ;      vcrop.upper AV
IO_60HZ_ratio_ycrop_lower_av_8bit db 0  ;set to ONE of six fixed values (00h,00h,00h,00h,00h,00h)  ;/     vcrop.lower AV
IO_60HZ_internal_unused3          db 0  ;   (unused)  ;bit5-7:NOT RW
IO_60HZ_internal_unused4          db 0  ;   (unused)
IO_60HZ_internal_unused5          db 0  ;   (unused)
IO_60HZ_internal_unused6          db 0  ;   (unused)  ;bit2-7:NOT RW
IO_60HZ_internal_unused7          db 0  ;   (unused)   ;bit7:minimal effect on WrongPAL60colors/ErrorShiftedDOWN or so?
IO_60HZ_boldness_contrast         db 0  ;initially(02h) ;<-- set AFTER other fixed FCxxh values, and later modified elsewhere (set to 00h or 02h) ;bit0-1:ExtraContrastOnPAL60colorError? ;bit2-7 NOT R/W
;---
IO_VIDEO_something_1_lsb      db 0     ;   fixed (16h)   ;\no visible effect when toggling bits
IO_VIDEO_something_1_msb      db 0     ;   fixed (01h)   ;/
 defs 2     ;unused (FFh-filled)    ;NOT RW
IO_VIDEO_something_2_lsb      db 0     ;   fixed (1Ch)   ;\no visible effect when toggling bits
IO_VIDEO_something_2_msb      db 0     ;   fixed (01h)   ;/
;--- above FC91h..FCB6h resembles FCBDh..FCE2h
;FCBCh..FCE2h has NO effect on PAL60 (affects PAL50 only)
IO_50HZ_control_lsb               db 0  ;initially(01h);\     <-- bit4 modified later on (alongsides FC92h)   ;bit1:MoveWholeImageCa.80pixLEFT Bit3:AV_BLACK/OFF, bit5:WeirdDiagonalStripyImage(ignoreHsync?), bit6:MoveWholeImageCa.12pixDOWN ;bits: various messes   ;C64: bit6:shows SNOW with downwards rolling VSYNC from C64)
IO_50HZ_control_mid               db 0  ;fixed (00h)   ;        ;bit0:AV_EdgyDiagonalColorError, bit3: AV diagonally messed(ignoredHsync?)    ;C64: bit0:shows SNOW with upwards rolling VSYNC from C64)
IO_50HZ_control_msb               db 0  ;fixed (00h)   ;/       ;bit2:MoveWholeImageCa.160pixLEFT, bit3:MoveWholeImageCa.32pixDOWNandWeakPixels     ;bits: horizontal & vertical AV+OSD picture position (too large: screen freezes/goes white?)
IO_50HZ_internal_unused1          db 0  ;   (unused)
IO_50HZ_internal_unused2          db 0  ;   (unused)
IO_50HZ_ratio_whatever_A_lsb      db 0  ;set to ONE of six fixed values (5Ch,84h,63h,63h,63h,63h)  ;\no visible effect when toggling bits
IO_50HZ_ratio_whatever_A_msb      db 0  ;set to ONE of six fixed values (08h,08h,03h,03h,03h,03h)  ;/
IO_50HZ_15khz_lsb                 db 0  ;fixed (66h)   ;\  ;\0466h (1126 decimal) ;maybe htotal*2?      ;15kHz rate? when wrong: stretch/squeeze AV vertically (with jitter in image)
IO_50HZ_15khz_msb                 db 0  ;fixed (04h)   ;   ;/
IO_50HZ_15khz_div2_lsb            db 0  ;fixed (36h)   ;   ;\0236h (566 decimal)  ;maybe vtotal*2?      ;15kHz rate? when wrong: stretch/squeeze AV vertically (with jitter in image)
IO_50HZ_15khz_div2_msb            db 0  ;fixed (02h)   ;   ;/               ;or, roughly, 466h/2 ?              ;<-- vscale (SNOW+OSD)
IO_50HZ_xloc_av_osd_lsb           db 0  ;fixed (02h)   ;   ;\word?     ;horizontal AV+OSD picture position (too large: screen freezes/goes white?)
IO_50HZ_xloc_av_osd_msb           db 0  ;fixed (00h)   ;   ;/
IO_50HZ_xloc_osd_lsb              db 0  ;fixed (36h)   ;   ;\word? 54  ;horizontal OSD picture position (too large: screen freezes/goes white?)
IO_50HZ_xloc_osd_msb              db 0  ;fixed (00h)   ;   ;/
IO_50HZ_xloc_av_lsb               db 0  ;fixed (43h)   ;   ;\word?     ;horizontal AV picture position
IO_50HZ_xloc_av_msb               db 0  ;fixed (00h)   ;   ;/
IO_50HZ_xcrop_end_av_lsb          db 0  ;fixed (92h)   ;   ;\word?
IO_50HZ_xcrop_end_av_msb          db 0  ;fixed (01h)   ;/  ;/          ;horizontal picture end crop
IO_50HZ_yloc_av_osd_lsb           db 0  ;fixed (08h)   ;\   <-- this one initialized after FCD1h..FCD7h      ;vertical picture position
IO_50HZ_yloc_av_osd_msb           db 0  ;fixed (00h)   ;/              ;nonzero: freeze (repeat current scanline in all lines)
IO_50HZ_yloc_osd_lsb              db 0  ;fixed (09h)   ;\            ;bit1-7 vertical OSD position? (also in bit0 of NEXT byte)
IO_50HZ_yloc_osd_msb              db 0  ;fixed (00h)   ;/         ;-when bit1-7 nonzero: AV screen black? (or maybe AV picture moved offscreen?)
IO_50HZ_ycrop_upper_av_lsb        db 0  ;fixed (0Ch)   ;\            ;AV vertical.picture.start crop coord?
IO_50HZ_ycrop_upper_av_msb        db 0  ;fixed (00h)   ;/         ;-when nonzero: AV screen black? (or maybe AV picture moved offscreen?)
IO_50HZ_heavy_flimmer_lsb         db 0  ;fixed (0Fh)   ;\         ;-flimmers... maybe vblank duration lsb, or interlace?
IO_50HZ_heavy_flimmer_msb         db 0  ;fixed (01h)   ;/         ;-vblank duration (large value causes screen to flicker/blink, getting BLACK during vblank)
IO_50HZ_ratio_xloc_av_8bit        db 0  ;set to ONE of six fixed values (06h,06h,0Ch,0Ch,0Ch,0Ch)  ;\   ;AV horizontal picture position
IO_50HZ_ratio_whatever_B_lsb      db 0  ;set to ONE of six fixed values (00h,00h,06h,06h,06h,06h)  ;-no visible effect when toggling bits
IO_50HZ_ratio_whatever_B_msb      db 0  ;set to ONE of six fixed values (00h,00h,00h,00h,00h,00h)  ;-no visible effect when toggling bits
IO_50HZ_ratio_ycrop_upper_av_8bit db 0  ;set to ONE of six fixed values (00h,00h,00h,00h,00h,00h)  ;    ;AV vertical.picture.start crop coord?
IO_50HZ_ratio_ycrop_lower_av_8bit db 0  ;set to ONE of six fixed values (00h,00h,00h,00h,00h,00h)  ;/   ;AV vertical.picture.end crop coord?
IO_50HZ_internal_unused3          db 0  ;   (unused)  ;bit5-7:NOT RW
IO_50HZ_internal_unused4          db 0  ;   (unused)
IO_50HZ_internal_unused5          db 0  ;   (unused)
IO_50HZ_internal_unused6          db 0  ;   (unused)  ;bit2-7:NOT RW
IO_50HZ_internal_unused7          db 0  ;   (unused)
IO_50HZ_boldness_contrast         db 0  ;initially(02h);<--- modified later, 00h or 02h     ;bit1:AV boldness?   ;bit2-7:NOT RW
;---
IO_VIDEO_something_3              db 0  ;fixed (01h) bit1-2: AV v-position
IO_VIDEO_something_4              db 0  ;used !!!!!!!!!!       bit4: AV h-position    (fixed 45h, except also ORed with 40h)
                                  db 0  ;   (unused)  ;NOT RW ;STAT (eg. 36h on SNES/PAL)
                                  db 0  ;   (unused)  ;NOT RW ;STAT (eg. 02h on SNES/PAL)
                                  db 0  ;   (unused)  ;bit2=this is RW!  ;other seven bits:NOT RW
                                  db 0  ;   (unused)  ;NOT RW ;STAT ;\without signal INCREASING 0..1xxh
                                  db 0  ;   (unused)  ;NOT RW ;STAT ;/with PSX.PAL toggles 11Dh/11Eh, with C64: toggles 11Bh/11Ch, with Spectrum toggles 11Ch/11Dh, with SNES/PAL: toggles 11Ch/11Dh, with SNES/PAL60: toggles 117h/118h(and has BlackWhiteDither... or wrong colors)
IO_VIDEO_something_5              db 0  ;used !!!!!!!!!!   ;NOT RW -- BUT firmware writes to it! (maybe write-only? or bug?) (read: always FFh?)
 defs 15h ;   unused (FFh-filled)  ;NOT RW
.errif $-0fd00h
;---
IO_PLL_00h               db 0  ;(unused)
IO_PLL_01h_cpu           db 0  ;(unused) ;bit0:hangs CPU
IO_PLL_02h_zoom          db 0  ;(unused) ;bit0:zoom/wobble?
IO_PLL_03h               db 0  ;(unused)
IO_PLL_04h               db 0  ;(unused)
IO_PLL_05h               db 0  ;(unused)
IO_PLL_06h               db 0  ;(unused)
IO_PLL_07h               db 0  ;(unused)
IO_PLL_08h               db 0  ;(unused)  ;NOT RW (value 00h)
IO_PLL_09h               db 0  ;(unused)  ;NOT RW (value 00h)
IO_PLL_dotclk_multiplier db 0  ;fixed (2Bh)        15kHz (also SNOW-boldness?)
IO_PLL_0Bh_used          db 0  ;used !!!!!!!!! (set to 40h twice)   ;bit0:forceNTSCcolor? bit1,3-7:force BLUE/SNOW (no AV), bit2:grayAVwrongXloc   ;C64: bit0/1 temporarily enable C64 image!!!
IO_PLL_0Ch               db 0  ;(unused)
IO_PLL_0Dh_cfg           db 0  ;fixed (F0h)        15kHz, upperbits: snow with rolling sync?
IO_PLL_0Eh_used          db 0  ;used !!!!!!!!! (set to 20h or 2Ch)   ;scanline freeze?
IO_PLL_dotclk_divider_1  db 0  ;fixed (03h)        15kHz  ... forcefully inserts VSYNCS every once-and-then?
IO_PLL_10h_cfg           db 0  ;fixed (twice set to 04h)  ;bit0-7changes: force BLUE/SNOW (maybe video clock? cannot detect picture when changed?)
IO_PLL_11h_used          db 0  ;used !!!!!!!!! ;\    ;XXX bit0? hangs CPU?, bit1-2?:OSDcharerror+hang?, bit4:OSD_BG_ONLY(noTEXT), bit5:scanlinefreeze(AV+OSD)
IO_PLL_12h_used          db 0  ;used !!!!!!!!! ;        DANGER: hang ADC?
IO_PLL_13h_used          db 0  ;used !!!!!!!!! ;/  screen on/off? (00h=off, FFh=on) (toggling single bits has no visible effect though)
IO_PLL_dotclk_divider_2  db 0  ;fixed (03h)   similar to FD0Fh
IO_PLL_dotclk_divider_3  db 0  ;fixed (02h)   similar to FD0Fh
IO_PLL_16h_cfg           db 0  ;fixed (03h)
IO_PLL_adc_clk_divider   db 0  ;fixed (18h)    IO_ADC analog related? (upper bits=SLOW) bit7=DANGER
IO_PLL_18h_pwm           db 0  ;(unused)     bit7:ForceMaxBacklight-->PWMdimmingOFF
IO_PLL_19h_used          db 0  ;used !!!!!!!!! (initially ORed by 81h, later set to 83h) ;bit0:NoSignal(withSmallVsyncRoll), bit6:Darker(AV+OSD), bit7:NoSignal(or occassionally/shortly AV with each scanline shown twice, at half width)
IO_PLL_1Ah_cfg           db 0  ;fixed (08h)
IO_PLL_1Bh               db 0  ;(unused)
IO_PLL_1Ch               db 0  ;(unused)
IO_PLL_1Dh               db 0  ;(unused)
IO_PLL_1Eh               db 0  ;(unused)
;---
IO_PWM_enable_flags        db 0  ;-VCOM_DC related  (bit0..3 = PWM0..3 enable?)
IO_PWM0_duty_total_lsb     db 0  ;\PWM_0 (backlight)
IO_PWM0_duty_total_msb     db 0  ;/
IO_PWM1_duty_total_lsb     db 0  ;\PWM_1 (SPI.DTA)
IO_PWM1_duty_total_msb     db 0  ;/
IO_PWM2_duty_total_lsb     db 0  ;\PWM_2 (SPI.CLK and SPI./RESET)
IO_PWM2_duty_total_msb     db 0  ;/
IO_PWM3_duty_total_lsb     db 0  ;\PWM_3 (SPI./CS)
IO_PWM3_duty_total_msb     db 0  ;/
IO_PWM0_duty_high_lsb      db 0  ;\PWM_0 (backlight)
IO_PWM0_duty_high_msb      db 0  ;/
IO_PWM1_duty_high_lsb      db 0  ;\PWM_1 (SPI.DTA)
IO_PWM1_duty_high_msb      db 0  ;/
IO_PWM2_duty_high_lsb      db 0  ;\PWM_2 (SPI.CLK and SPI./RESET)
IO_PWM2_duty_high_msb      db 0  ;/
IO_PWM3_duty_high_lsb      db 0  ;\PWM_3 (SPI./CS)
IO_PWM3_duty_high_msb      db 0  ;/
;--- below are probably 4bit mode value for each chip.pin...
IO_PIN_maybe0                   db 0     ;- (unused)
IO_PIN_P06_P07_pwm              db 0     ;- used !!!!!!!   PWM2/PWM3
IO_PIN_P10_P11_spi_flash        db 0     ;\        <-- DANGER maybe SPI flash?
IO_PIN_P12_P13_spi_flash        db 0     ;         <-- DANGER maybe SPI flash?
IO_PIN_P14_P15_lcd              db 0     ;
IO_PIN_P16_P17_lcd              db 0     ;
IO_PIN_P20_P21_lcd              db 0     ; fixed
IO_PIN_P22_GPIO0_lcd            db 0     ;                                      ;bit0:addsDarkBLUEtoTFT, bit4:addsMoreBLUEtoTFT
IO_PIN_GPIO1_GPIO2_lcd          db 0     ; 16 bytes, set to 11h
IO_PIN_GPIO3_GPIO4_lcd          db 0     ;
IO_PIN_P23_P24_lcd              db 0     ;    32x4bit (with value 1h)           ;bit4:addsDarkGREENtoTFT
IO_PIN_P25_P26_lcd              db 0     ;    aka MODE for LCD pins             ;bit0:addsMoreGREENtoTFT, bit4:addsMANYGREENtoTFT
IO_PIN_GPIO5_GPIO6_lcd          db 0     ;    (24xRGB, 4xSYNC, 4xSPI_FLASH)
IO_PIN_GPIO7_GPIO8_lcd          db 0     ;
IO_PIN_GPIO9_GPIO10_lcd         db 0     ;
IO_PIN_P27_P30_lcd              db 0     ;                                      ;bit0:addsDarkREDtoTFT, bit4:addsMoreREDtoTFT
IO_PIN_P31_P32_lcd              db 0     ;     <--dotclk?                       ;bit0:StopDotClk, bit1:HigherDotClk/HIRES, bit2:LowerDotClk/LORES
IO_PIN_P33_P34_lcd              db 0     ;/                                     ;bit0:KillTftUpdating, bit1:MoveWholeImageCa.40pixLEFTandShake+/1pix, bit2:slightlyShaky, bit4:FreezeScanline, bit5:KillTftUpdating
IO_PIN_P35_P36_pwm              db 0     ;-used !!!!!!!   PWM0/PWM1             ;bit0-2:ScreenBlack(backlight)
IO_PIN_P37_xxx_pwm              db 0     ;-used !!!!!!!   PWM2'/..
IO_PIN_maybe1_01h               db 0     ;\   <-- set to 01h (maybe REMOTE or ADC0 or so)               ;bit0:KillTftUpdating
IO_PIN_maybe2_zero              db 0     ;
IO_PIN_maybe3_zero              db 0     ;
IO_PIN_maybe4_zero              db 0     ; fixed
IO_PIN_maybe5_zero              db 0     ;
IO_PIN_maybe6_zero              db 0     ;
IO_PIN_maybe7_zero              db 0     ;
IO_PIN_maybe8_zero              db 0     ;/
                                defs 4   ;- (unused)
IO_whatever_FD50h               db 0     ;- used !!!!!!! (initially 00h, then set to 0Bh)   ;bit5:KillTftUpdating
IO_whatever_zerofilled:         defs 0ah ;- fixed (zerofilled)  maybe a buffer for I2C or REMOTE or so?
                                defs 5h  ;- (unused)
 defs 50h  ;unused (FFh-filled)  ;NOT RW
;--- I/O Keyboard analog input...
IO_ADC_ctrl_lsb     db 0    ;\                  ;DANGER:bit1-2  ;bit0:NOT RW (whilst other bits ARE R/W)
IO_ADC_ctrl_msb     db 0    ;/
IO_ADC_config_1     db 0     ;   ...fixed (20h)      ;DANGER:bit1   ;bit6-7:NOT RW
                    db 0     ;   (unused)  ;NOT RW (value 00h)
IO_ADC_config_2     db 0     ;   ...fixed (22h)  ;\  ;DANGER:bit7
IO_ADC_config_3     db 0     ;   ...fixed (37h)  ;/  ;DANGER:bit0-1
IO_ADC_config_4     db 0     ;   ...fixed (FFh)  ;\
IO_ADC_config_5     db 0     ;   ...fixed (FFh)  ;/
IO_ADC_status_lsb   db 0            ;\WRITE ZERO (=ack?)   ;NOT RW--asideFromAck'ing
IO_ADC_status_msb   db 0            ;/                     ;NOT RW--asideFromAck'ing
                    db 0     ;   (unused)           ;NOT RW (value 00h)
                    db 0     ;   (unused)           ;NOT RW (value 00h)
IO_ADC_input_0_lsb  db 0     ;\analog 0 (keypad)    ;NOT RW ;STAT
IO_ADC_input_0_msb  db 0     ;/                     ;NOT RW
IO_ADC_input_1_lsb  db 0     ;\analog 1             ;NOT RW
IO_ADC_input_1_msb  db 0     ;/                     ;NOT RW
IO_ADC_input_2_lsb  db 0     ;\analog 2             ;NOT RW
IO_ADC_input_2_msb  db 0     ;/                     ;NOT RW
                    defs 6   ;   (unused)  ;NOT RW (values 00h-filled)
IO_ADC_config_6     db 0     ;   ...fixed (FFh)
IO_ADC_config_7     db 0     ;   ...fixed (0Fh)
IO_ADC_config_8     db 0     ;   ...fixed (00h)
                    db 0     ;   (unused)  ;NOT RW (value 00h)
IO_ADC_speed_lsb    db 0     ;   ...fixed (FFh)
IO_ADC_speed_msb    db 0     ;   ...fixed (0Fh) (changing upper bits makes ADC slower)
                    db 0     ;   (unused) ;bit7 is R/W !!!, bit0-6: NOT R/W (read-only, contains 1Fh)
                    db 0     ;   (unused)                  ;bit4-7: NOT R/W
;--- Serial SPI FLASH... (and also SPI FLASH to VRAM DMA?)
IO_SPI_transfer_mode      db 0     ;spi.flash...whatever, set ONE bit? (used: 04h,08h,10h,40h,80h) ;DANGER
 ;FlashCmd01h = Manual read JEDEC Chip ID (used by newer firmware only)
 ;FlashCmd02h = Manual read Write-Protect-Status (used by unused function in newer firmware only)
 ;FlashCmd04h =   idle? for enter/enable read/erase mode (or maybe some sort of "read/check status"?)
 ;FlashCmd08h =   ERASE flash step 1 & 2 (also for read_mode_step_2 ???)
 ;FlashCmd10h = Manual read flash-to-cpu
 ;FlashCmd20h =   (unused)
 ;FlashCmd40h = DMA read  flash-to-vram
 ;FlashCmd80h = DMA write ram-to-flash
IO_SPI_wprot_stat_write db 0     ;spi.flash.write.protect.status.write
IO_SPI_manual_data_read db 0     ;spi.flash.data.READ (for MANUAL non-DMA access)  ;NOT RW
IO_SPI_chip_id_read_msb db 0     ;CHIP ID   (used by new firmware)  ;NOT RW (value 00h)
IO_SPI_chip_id_read_mid db 0     ;CHIP ID   (used by new firmware)  ;NOT RW (value 00h)
IO_SPI_chip_id_read_lsb db 0     ;CHIP ID   (used by new firmware)  ;NOT RW (value 00h)
IO_SPI_flash_addr_lsb   db 0     ;spi.flash.addr.lsb  ;\for VRAM upload, this is
IO_SPI_flash_addr_mid   db 0     ;spi.flash.addr.mid  ; SPI FLASH addr, too
IO_SPI_flash_addr_msb   db 0     ;spi.flash.addr.msb  ;/(ie. it's transferring SPI-to-VRAM)
IO_SPI_dma_ram_addr_lsb db 0     ;spi.ram/vram.addr.lsb ;\maybe DMA addr on CPU RAM? and/or VIDEO RAM?
IO_SPI_dma_ram_addr_msb db 0     ;spi.ram/vram.addr.msb ;/
IO_SPI_dma_length_lsb   db 0     ;spi.flash/vram.dma.len.lsb ?   ;\not used for FLASH READ (which is done via MANUAL BYTE loop)
IO_SPI_dma_length_msb   db 0     ;spi.flash/vram.dma.len.msb ?   ;/  (but used for FLASH WRITE, and VRAM UPLOADS)
IO_SPI_ready_flags      db 0     ;spi.flash.ready.flags (corresponding to start.bits in FDD0h)
IO_SPI_kick_stop_reset  db 0     ;spi.flash.80h    ;write 80h to start/stop/reset ?
IO_SPI_status_ready     db 0     ;spi.flash.status  (bit7: 0=busy, 1=ready)  ;NOT RW
                        db 0     ;   (unused) DANGER!
                        defs 3   ;   (unused)
IO_SPI_command_write    db 0     ;spi.flash.command
                        defs 3h  ;   (unused)
 defs 8    ;unused (FFh-filled)   ;NOT RW
;---
                        db 0     ;   (unused)
IO_SPI_upper_32k_code_base   db 0     ;   (unused) bit0-3:DANGER!
 defs 0eh  ;unused (FFh-filled)   ;NOT RW
.errif $-0fe00h
;--- --- --- AV inputs...?
                        db 0     ;   (unused)  ;bit4:vertical.boldness, bit5:temporarilyNoSignal, bit7:Force_NTSC_Colors?
IO_AV_ctrl_whatever_1   db 0     ;   used !!!!!!!! (bit1 set/cleared, bit4 set)  ;bit0:ForcePALcolors_ButYetPAL60getsWrongYloc, ;bit2:Force_PAL_Color_But_Only_If_FE00h.bit7 is toggled  ;;;(bit0 is similar as FE01h.bit0) (HERE: bit2 has NO effect if FE00h.bit7=x)
                        db 0     ;   (unused)
                        db 0     ;   (unused)
IO_AV_config_FE04h      db 0     ;   fixed (set to 30h)  ;\
IO_AV_config_FE05h      db 0     ;   fixed (set to 40h)  ;/
                        defs 0dh ;   (unused)
                           ;FE0Dh:bit7:Untoggle=BlinksAvWhiteRecalib?,
                           ;FE0Fh.bit0/1/2=Change=TemporarilyNoSignal,
                           ;FE0Fh.bit3:ForcePALcolors_ButYetPAL60getsWrongYloc (similar as FE01h.bit0) (HERE: effect is inverse if FE00h.bit7=x --> then forces NTSC colors)
                           ;FE11h.bit2,4,5,6,7:ShortColorRollThenShowDitheredBlackWhiteAvImage
IO_AV_config_FE13h      db 0     ;   fixed (set to 1Eh)
                        db 0     ;   (unused)
IO_AV_ctrl_sensitivity_0        db 0     ;   used !!!!!!!! (set to 00h=max,05h=med,09h=low, also checked if 05h)  (bit2,3:PixelBoldness)
                                defs 10h ;   (unused)  ;FE17h.bit1=Boldness, FE17h.bit4,5=BoldnessWithContrast, FE17h.bit6,7=PermanentlyToggleColoredAndDitheredBlackWhiteLines, FE18h.bit1,2=BoldnessAndRightScreenEdge, FE18h.bit6,7=PermanentlyToggleColoredAndDitheredBlackWhiteLines, FE1Dh.bit6=NoSignalOrWeirdColorRoll, FE1Dh.bit7:NOT RW, FE1Eh.bit6=NoSignalOrWeirdColorRoll, FE1Eh.bit7:NOT RW, FE1Fh.bit7:NOT RW, FE20h:NOT RW, FE21h:NOT RW       ;FF20h.6-7: C64/SNOW color  ;XXX why FFxxh? THIS is FExxh!!!
IO_AV_stat_detect_0             db 0     ;   used !!!!!!!! ...status    video DETECT ? OFTEN used           ;NOT RW
IO_AV_stat_detect_1             db 0     ;   used !!!!!!!! ...status (bit0 tested, used by only ONE opcode) ;NOT RW
IO_AV_stat_framerate_flag       db 0     ;   used !!!!!!!! ...status    bit2 = PAL/NTSC and/or 50/60 Hz     ;NOT RW
                                db 0     ;   (unused)
IO_AV_stat_signal_detect        db 0     ;   used !!!!!!!! ...status (bit6 and bit0-3 used)   (bit4:HaveCVBS1, bit6:HaveCVBS3, bit0,1,2,3=ErrorFlag(s))     ;NOT RW
                                defs 5   ;   (unused)    ;FE2Dh.bit7:ShortColorRollThenBlackWhiteDither
                                defs 12h ;   (unused)
                                   ;FE31h.bit7=NoSignal,
                                   ;FE39h.bit4-7:NOT RW,
                                   ;FE3Ch.bit5=Boldness,
                                   ;FE3Ch.bit6=BoldnessAndWashyBackground(SnesLooksAsWashyAsC64),
                                   ;FE3Ch.bit7:BoldnessBrighterBlack,
                                   ;FE3Dh.bit6:UltraWashyBlurr,
                                   ;FE3Dh.bit7=RollingImageAndBlackWhiteDither,
                                   ;FE3Fh.bit1-7:NOT RW,
                                   ;FE41h.bit6:TrueSnow?(not the artifical snow effect),
                                   ;FE41h.bit7:freezeSNOW (stuck BG or WHITE) and/or snow with wandering vblanking bars
                                     ;C64: FE41h.6-7: vague picture/sync traces?
                                     ;C64: FF4Ah.7/FF4Bh.7/C64: bluish   ;XXX why FF4xh? THIS is FE4xh!!!
IO_AV_secret_control            db 0  ;<-- unused by firmware, but has useful functions...
                                      ;FE42h.bit0-2 slight horiz.position changes,
                                      ;FE42h.bit3:blurRightScreenEdge,
                                      ;FE42h.bit4=NoSignal,
                                      ;FE42h.bit5=C64 does PERFECTLY SHOW C64 IMAGE !!! (and still switches to SNOW when C64 is OFF)
                                      ;FE42h.bit6=WrongColor(LightblueInsteadRedInSnesDiagAndPickupWashynessIfC64isPoweredOnOnAV2... or is that S-Video with Chroma from AV2 ???)
                                defs 0dh ;   (unused)
                                   ;FE43h=Somewhat Lumafactor/Lumaoffset for white-pixels getting brighter, when bit7 changed: white pixels are becoming BLACK
                                   ;FE44h.bit5=LessBoldness
                                   ;FE44h.bit6=AllMuchBrighter(including brighter black)
                                   ;FE44h.bit7=AllVERYMuchBrighter(including brighter black)
                                   ;FE45h.bit7=MonochromeImage(not dithered), with Washyness if C64 is PoweredOn on AV2)
                                   ;FE47h.bit7=ReddishMagentaInsteadRed, with Washyness if C64 is PoweredOn on AV2)
                                   ;FE48h.bit6=BlackWhiteDitheredImage
                                   ;FE4Bh.bit7:NOT RW
                                   ;FE4Dh.bit3-7:NOT RW
                                   ;FE4Eh.bit6: C64: UNTOGGLING FE4Eh.6 does show C64 image for short moment (no effect on SNES image)
                                   ;FE4Fh.bit7:NOT RW
                                defs 4   ;   (unused)   ;C64: FE50h.6,7 does show C64 image going on and off (no effect on SNES image)
IO_AV_ctrl_whatever_2           db 0     ;   used !!!!!!!! ...initially 00h, bit6 is manipulated later on
                                db 0     ;   (unused)   ;bit4:AlmostCompletelyOmitsSomePalScanlines(instead of resampling them from PAL to 240pix-LCD-resolution), bit5:SameAsBit4(but affecting OTHER lines)
IO_AV_config_FE56h              db 0     ;   fixed (set to 00h)
                                defs 9   ;   (unused)
                                db 0     ;   (unused)
                                   ;FE60h.bit1: when changed: ShortlyFlashesOrShortlyNoSignal
                                   ;FE60h.bit3: SNES: dims white to BluishGray and/or shortly NoSignal
                                   ;FE60h.bit3: C64: rolling white stripes when C64 ON
                                defs 8   ;   (unused)
 defs 7  ;unused (FFh-filled) ;NOT RW
                                defs 0Eh ;   (unused)
                                db 0    ;NOT RW (value FFh)
                                db 0    ;    (unused) (value FFh, but this one is write-able)
;---next 80h bytes are many STAT values (counters or levels or so?) (especially active when AV signal present)
                                db 0     ;   (unused)  ;FE80h.bit7=ForcesBlackImage
                                defs 1   ;unused (FFh-filled)
                                db 0     ;   (unused)
IO_AV_config_FE83h              db 0     ;   fixed (FEh)
                                defs 1ch ;   (unused)
                                   ;FE84h..FE89h:NOT RW  ;STAT? (two negative 16bit values, and another 2 bytes?)
                                   ;FE8Bh.bit7:NOT RW
                                   ;FE8Ch.NOT RW (value 17h)
                                   ;FE8Dh.bit3-7:NOT RW
                                   ;FE8Eh.bit5-7:NOT RW
                                   ;FE90h..FE9Fh:NOT RW
IO_AV_force_resync              db 0     ;   used !!!!!! (bit0 manually pulsed with SLOW DELAYS)  ;C64: UNTOGGLING bit7: does SHOW C64 image for short moment)
                        ;FEA0h.bit0 sometimes causes NoSignal, and simetimes FreezesCurrentScanline (THAT affecting BOTH OSD AND AV !!!)
                        ;FEA0h.bit1 move AV image 1pix UP, and ca.8pix RIGHT
                        ;FEA0h.bit2-7:NOT RW
                                defs 9   ;   (unused)
                        ;FEA1h:NOT RW ;STAT (value Fxh)
                        ;FEA2h.bit3-7:NOT RW
                        ;FEA3h..FEA9h:NOT RW  (STAT)
IO_AV_stat_sensitivity_msb      db 0     ;   used !!!!!! ;NOT RW ;\16bit status/counter?  (NoSignal:0FFFh, C64:0287h..028Bh=647..651)
IO_AV_stat_sensitivity_lsb      db 0     ;   used !!!!!! ;NOT RW ;/
                                defs 9   ;   (unused)
                        ;FEACh..FEB1h:NOT RW  (STAT)
                        ;FEB2h.bit7:NOT RW
                        ;FEB3h:NOT RW  (STAT)
                        ;FEB4h.bit7:THIS looks like S-Video (picks Snes/Luma from AV1, but C64/Chroma from AV2, showing hatchy blue borders at wrong hsync)
IO_AV_config_FEB5h              db 0     ;   fixed (set to 67h)
                                defs 4   ;   (unused)
                        ;FEB6h.bit5-7:NOT RW
                        ;FEB7h.bit0: Moves image 1pix LEFT
                        ;FEB7h.bit1-7:NOT RW
IO_AV_config_FEBAh              db 0     ;   fixed (set to FFh)
                                defs 0eh ;   (unused)
                        ;FEC5h-FEC7h:NOT RW  (values 00h)
                        ;FEC8h.bit0:DitheredBlackWhite
                        ;FEC8h.bit7: move image ca.80pix RIGHT and ca.12pix UP
IO_AV_config_FEC9h              db 0
                        ;FEC9h.bit1: LessBoldness
                        ;FEC9h.bit6: DitheredAllGreenImage(GREEN !!!)
                                defs 1   ;   (unused)
                        ;FECAh.bit0: UntogglingShortlyDimsBrightness
                        ;FECAh.bit1: UntogglingShortlyBlinksWhitePixels
IO_AV_ctrl_artifacts            db 0     ;   used !!!!!!!! (set to 00h, 02h, or 06h)
                        ;FECBh.bit0: NICE: LessPalArtifactsOnSNES
                        ;FECBh.bit1: Similar as bit0, but with magenta-line at bottom of red-snes-screen
                                defs 4   ;   (unused)
                        ;FECEh-FECFh:NOT RW  (reads as DFh,73h with PAL/SNES)
IO_AV_stat_detect_2             db 0     ;   used !!!!!!!!! ...status   ;NOT RW
                                defs 4   ;   (unused)
                        ;FED1h.bit5,6:UponChanges:ShortlyNoSignal
                        ;FED1h.bit7: NOT RW
                        ;FED3h.bit2-7: NOT RW
                        ;FED4h.bit1: OverBright(andWashyIfC64 is powered on AV2)
IO_AV_ctrl_sensitivity_1        db 0     ;   initially B1h, modified/used later
                                db 0     ;   (unused)
                        ;FED6h.bit3: Snowy random Red/Magenta pixels (instead of SNES with Red background) (and if C64 powered on AV2: diagonally striped Red/Magenta) (might be also S-Video, chroma from AV2?)
                        ;FED6h.bit7: ShortlyNoSignal, then UberOverBrightImage (and Washy if C64 also powered on on AV2)
                        ;FED6h.bit7.onC64: bit7: does SHOW C64 image (once and then, goes on and off) (this is best result yet)
IO_AV_video_on_off              db 0     ;   used !!!!!!!!!  lcd-control/enable or so  ;bit0+1+6+7:disable SNOW (freeze backdrop-color or snow-color, and occassionally also freeze current OSD scanline!)
IO_AV_input_select_reg_0        db 0     ;   used !!!!!!!!!  lcd-input select related                        ;C64: bit7=whitish stripes when C64 ON  ;SNES: bit7=ShortlyWhiteStripes...ThenAllWhite (looks as if snow/random generator ends up with all-white pixels)
IO_AV_config_FED9h_bits         db 0     ;   used !!!!!!!!!  (bit4-5 cleared, bit6 set)
                                db 0     ;   (unused)
IO_AV_config_FEDBh_bit          db 0     ;   used !!!!!!!!!  (bit7 cleared)
IO_AV_input_select_reg_1        db 0     ;   used !!!!!!!!!  lcd-input select
                        ;FEDCh.bit4: Toggle=BlueBackdrop(without snow), Untoggle: ShortlyNoSignal(with snow)ThenNormalPicture
                        ;FEDCh.bit5: NoSignal ;or, if C64 powered on AV2: white picture with blue/rolling hsync/vsync signals?
                        ;FEDCh.bit6: BlueBackdrop(without snow, except a VERY FEW random/snow pixels in some rolling-screen-half)
                        ;FEDCh.bit6: Like bit6, but with a little bit more random/now pixels)
                        ;C64: bit7: minimal SNOW when C64 ON
                                defs 0fh ;   (unused)  ;NOT RW (STAT) (not FFh, except, FEEAh is usually FFh, and FEEBh is OFTEN FFh, but can become EFh when plugging/unplugging AV cable)
 defs 04h  ;unused (FFh-filled)                        ;NOT RW
;---
                                defs 0eh ;   (unused)  ;NOT RW (STAT) (not FFh)
 defs 02h  ;unused (FFh-filled)                        ;NOT RW
;--- --- ---
IO_LCD_config_FF00h      db 0     ;-I/O Init to fixed value (03h)   ;bit0/1:AffectAvColorBrightnessOrSo maybe GammaRampMode/Enable?
IO_LCD_gamma_ramp_red:   defs 1fh ;\RGB gamma ramps (init to increasing values)
IO_LCD_gamma_ramp_green: defs 1fh ; (affects AV video and YCbCr backdrop and "white" snow)
IO_LCD_gamma_ramp_blue:  defs 1fh ;/(ALSO affects OSD colors, except BRIGHT one like WHITE/YELLOW/etc)
;--- --- ---
;registers FF5Eh..FFA3h are unused by old firmware (but
;some used for Infrared in new firmware)
;none of the FF5Eh..FFA3h registers has any visible effect
;when toggling ANY bits in this area (tested with SNES at PAL60)
;- - -
IO_LCD_whatever_FFh_1 db 0  ;=FFh ;\
IO_LCD_whatever_FFh_2 db 0  ;=FFh ;
IO_LCD_whatever_FFh_3 db 0  ;=FFh ;/
;- - -
IO_IR_config_FF61h    db 0  ;=05h ;\
IO_IR_config_FF62h    db 0  ;=3Fh ;
IO_IR_config_FF63h    db 0  ;=10h ;
IO_IR_config_FF64h    db 0  ;=04h ;  ;<--FF64h.bit3-7:NOT RW
IO_IR_config_FF65h    db 0  ;=76h ;
IO_IR_config_FF66h    db 0  ;=3Bh ;
IO_IR_config_FF67h    db 0  ;=08h ;
IO_IR_config_FF68h    db 0  ;=15h ;
IO_IR_config_FF69h    db 0  ;=07h ;
IO_IR_config_FF6Ah    db 0  ;=00h ;
IO_IR_config_FF6Bh    db 0  ;=00h ;  ;<--NOT RW (but is written!?!)
IO_IR_config_FF6Ch    db 0  ;=00h ;  ;<--NOT RW (but is written!?!)
IO_IR_config_FF6Dh    db 0  ;=00h ;  ;<--NOT RW (but is written!?!)
IO_IR_config_FF6Eh    db 0  ;=00h ;  ;<--NOT RW (but is written!?!)
IO_IR_config_FF6Fh    db 0  ;=76h ;
IO_IR_config_FF70h    db 0  ;=1Ch ;
IO_IR_config_FF71h    db 0  ;=08h ;
IO_IR_config_FF72h    db 0  ;=F5h ;/
                      defs 4
IO_IR_config_FF77h    db 0  ;=59h ;\
IO_IR_config_FF78h    db 0  ;=00h ;
IO_IR_config_FF79h    db 0  ;=01h ;
IO_IR_config_FF7Ah    db 0  ;=73h ;
IO_IR_config_FF7Bh    db 0  ;=FFh ;
IO_IR_config_FF7Ch    db 0  ;=02h ;
IO_IR_config_FF7Dh    db 0  ;=0Fh ;/
                      defs 4
IO_IR_config_FF82h    db 0  ;=01h ;- ;<--FF82h.bit4-7:NOT RW
IO_IR_stat_FF83h_used db 0       ;\ ;<--NOT RW
                      db 0       ;  ;<--NOT RW
IO_IR_stat_FF85h_used db 0       ;  ;<--NOT RW
                      db 0       ;  ;<--NOT RW
                      db 0       ;/ ;<--NOT RW
                      defs 4     ;   (unused by firmware) <-- no visible effect when toggling ANY bits in this area (tested with SNES at PAL60)
                      db 0       ;  ;<--FF8Ch.bit6-7:NOT RW
                      defs 5     ;  ;<--FF8Dh-FF91h:NOT RW
                      defs 0Dh   ;  ;<--fully R/W
                      db 0       ;  ;<--FF9Fh.bit6-7:NOT RW
                      defs 4     ;  ;<--fully R/W
;---
 defs 0ch  ;unused (FFh-filled)  ;NOT RW
;---
IO_LCD_snow_enable_and_misc db 0     ;used !!! initially 22h ;backdrop ctrl  ;bit7:snow(0=off, 1=on), bit5: always 1? or bit5: disable picture?    bit0:affects AV picture NTSC? bright?    ;C64: bit5,7=bluish (and bit5: OSD position/yscale depending on C64 on/off?)
IO_LCD_sharpness_or_so      db 0     ;   used !!!    bit0: AV bolder/brighter/smeared pixels  sharpness?  ;bit3:VeryBlurry    ;C64: bit4,6:bluish
IO_LCD_config_FFB2h         db 0     ;   fixed (20h)
IO_LCD_config_FFB3h         db 0     ;   fixed (20h)
IO_LCD_config_FFB4h         db 0     ;   fixed (20h)
                            db 0     ;   (unused by firmware)
                            db 0     ;   (unused by firmware)
IO_LCD_config_FFB7h         db 0     ;   fixed (twice set to 90h)
                            defs 8   ;   (unused)    ;FFB8h:bit7:BrighterBlack
                            defs 0bh ;   (unused)
IO_LCD_whatever_FFCBh       db 0     ;   ;\ init to 80h/2Ah ;<--- this byte also via init list  ;bit0:DarkerOSD?
IO_LCD_config_FFCCh         db 0     ;   ;  init to 80h            ;bit6:WholeScreenMintgreen? (no AV, no OSD), bit7:BrighterBlack  ;when FFCEh-FFD0h=00,00,00: bit=WholeScreenBlack(insteadMintGreen)
IO_LCD_config_FFCDh         db 0     ;   ;/ init to 2Dh
IO_LCD_backdrop_color_Y     db 0  ;\three-byte-group (Y,Cb,Cr) (all unsigned 8bit)
IO_LCD_backdrop_color_Cb    db 0  ;   for BLUE:       13h,DDh,72h
IO_LCD_backdrop_color_Cr    db 0  ;/  for BLACK/SNOW: 00h,80h,80h
                            db 0     ;   (unused)      ;bit6:BrighterBlack
IO_LCD_forced_blank_color   db 0  ;Forced Blank Color (set to 4Fh..55h depending on Settings, and on display on/off) (4Fh=show AV video (or backdrop/snow), 5xh=force blank screen with fixed color) (does NOT affect OSD, affects only AV+backdrop+snow)  ;for AV:bit0=swapRed/Blue, bit1=mess, bit2=dim?, bit3:AV_OFF/BLACK(OSD only)  ;C64: bit7:bluish on C64
IO_LCD_basic_contrast       db 0  ;Contrast
IO_LCD_basic_brightness     db 0  ;Brightness
IO_LCD_basic_tint           db 0  ;Tint (for NTSC only)
IO_LCD_basic_saturation     db 0  ;Saturation
IO_LCD_config_FFD7h         db 0     ;   fixed (10h)
IO_LCD_whatever_FFD8h       db 0     ;   used !!!!!!!!!!  (bit7 set/cleared) (set for BLUE, has no visible effect though)
                            db 0     ;   (unused)
IO_backdrop_snow_level      db 0     ;   fixed (6Ch)  ;amount of white snow pixels (bit0-3=amount?, bit4-6=width, bit7=?)
                            defs 2   ;   (unused)
 defs 1    ;unused (FFh-filled) ;NOT RW
                            defs 0dh ;   (unused) <-- no visible effect when toggling ANY bits in this area (tested with SNES at PAL60)
 defs 5h   ;unused (FFh-filled) ;NOT RW
IO_LCD_config_FFF0h         db 0     ;   fixed (1Ah)                ;\
IO_LCD_config_FFF1h         db 0     ;   fixed (06h)                ; affects AV color decoding
IO_LCD_config_FFF2h         db 0     ;   fixed (D4h)                ; ...
IO_LCD_config_FFF3h         db 0     ;   fixed (D2h)                ;
IO_LCD_config_FFF4h         db 0     ;   fixed (F1h)  ;<-- F1h
IO_LCD_config_FFF5h         db 0     ;   fixed (0Eh)
IO_LCD_config_FFF6h         db 0     ;   fixed (15h)
IO_LCD_config_FFF7h         db 0     ;   fixed (E4h)
IO_LCD_config_FFF8h         db 0     ;   fixed (F6h)
IO_LCD_config_FFF9h         db 0     ;   fixed (F1h)  ;<-- F1h, too
IO_LCD_config_FFFAh         db 0     ;   fixed (1Bh)
IO_LCD_config_FFFBh         db 0     ;   fixed (81h)
.errif $-0fffch
 defs 4h   ;unused (FFh-filled)  ;NOT RW
.errif $-0000h     ;aka 10000h
;------------------
;further unknown ports that should exist
;  PLL control for 27MHz vs PAL/NTSC clocks
;  IR input for REMOTE pin
;  I2C bus
;  OSD blink/highlight (for THREE windows?)
;------------------
org 0
;---Internal RAM...
 defs 8         ;reserved for CPU registers r0..r7

analog_key_counts: defs 8
sys_vblank_flag    db 0
keyrepeat_delay    db 0
oldkey             db 0
sys_random         dw 0
;- - -
sys_vars_end:
;- - -
iram_sysgui_menu_index         db 0
iram_sysgui_menu_param_msb     db 0
iram_sysgui_menu_param_lsb     db 0
iram_sysgui_menu_text_msb      db 0
iram_sysgui_menu_text_lsb      db 0
iram_sysgui_timeout            db 0

iram_old_AV_framerate     db 0  ;old signal
iram_timer1_irq_counter   db 0  ;irq counter
iram_ir_msb_device        db 0  ;\USED by newer version ;(older version: blah, set to FFh in several places)
iram_ir_lsb_cmd           db 0  ;/
 defs 20h-$
iram_tmp__23h             db 0  ;  for irq   ...IO_AV_stat_signal_detect(4bit), and msb 8bit from IO_AV_stat_sensitivity_msb
iram_tmp__24h             db 0  ;  for irq   ...IO_AV_stat_detect_2(8bit),      and lsb 8bit from IO_AV_stat_sensitivity_lsb
iram_firm_stack:  defs 100h-$
.errif $-100h
;---
;below "(xxx)" names are P8xCE558 ports (not 8031/8051)
;they are apparently having OTHER SPECIAL meanings on the video chip (?)
;below internal I/O are used, but unknown what they do
SFR_IO_PORT0_DATA       equ 080h    ;bit6: force screen white
SFR_CPU_sp              equ 081h
SFR_CPU_dpl             equ 082h  ;\aka 16bit dptr
SFR_CPU_dph             equ 083h  ;/
 ;unused                equ 084h
 ;unused                equ 085h
 ;unused                equ 086h    ;NOT R/W  ;bit0:DANGER
SFR_IO_PCON             equ 087h    ;bit0-1:DANGER(halt/idle?), bit2-3,6-7:R/W, bit4-5:NOT R/W
SFR_IO_TCON             equ 088h      ;bit3:NOT R/W
SFR_IO_TMOD             equ 089h
SFR_IO_timer0_lsb       equ 08Ah
SFR_IO_timer1_lsb       equ 08Bh    ;some NOT R/W (aka updated by HW)
SFR_IO_timer0_msb       equ 08Ch
SFR_IO_timer1_msb       equ 08Dh
SFR_IO_whatever_config  equ 08Eh        ;-lower 3bits set
 ;unused                equ 08Fh    ;bit0:SKIPPED???(maybe forces ADC=ready), bit1-7:NOT R/W
;SFR_IO_PORT1_DATA      equ 090h              ;00
SFR_IO_xxx91h           equ 091h    ;bit0-3:NOT R/W   ;-four extra IRQ flags (bit4=ADC?)
;SFR_IO_xram_bank       equ 092h ;upper 8bit of XRAM address (when using 8bit addr via "movx [r0]", eg. allows to access 2K XRAM at 0000h-07FFh, and I/O ports at FB00-FFFFh) (not used by firmware)
 ;unused                equ 093h     ;NOT R/W ;00
 ;unused                equ 094h     ;NOT R/W ;00
 ;unused                equ 095h     ;NOT R/W ;00
 ;unused                equ 096h     ;NOT R/W ;00
 ;unused                equ 097h     ;NOT R/W ;00
SFR_IO_sio_scon         equ 098h              ;scon
;SFR_IO_sio_sbuf        equ 099h     ;NOT R/W ;00 (R) and (W)
 ;unused                equ 09Ah     ;NOT R/W ;00
 ;unused                equ 09Bh     ;NOT R/W ;00
 ;unused                equ 09Ch     ;NOT R/W ;00
 ;unused                equ 09Dh     ;NOT R/W ;00
 ;unused                equ 09Eh     ;NOT R/W ;00
 ;unused                equ 09Fh     ;NOT R/W ;00
;SFR_IO_PORT2_DATA      equ 0A0h        ;00
 ;unused                equ 0A1h        ;00
 ;unused                equ 0A2h        ;00
 ;unused                equ 0A3h        ;00
 ;unused                equ 0A4h        ;00
 ;unused                equ 0A5h        ;00
 ;unused                equ 0A6h        ;00
 ;unused                equ 0A7h        ;00
SFR_IO_iec              equ 0A8h        ;iec
 ;unused                equ 0A9h        ;00
 ;unused                equ 0AAh        ;00
 ;unused                equ 0ABh        ;00
 ;unused                equ 0ACh        ;00
 ;unused                equ 0ADh        ;00
 ;unused                equ 0AEh        ;00
 ;unused                equ 0AFh        ;00
SFR_IO_PORT3_DATA       equ 0B0h
SFR_IO_timer3_lsb       equ 0B1h        ;\faster timer (incrementing)
SFR_IO_timer3_msb       equ 0B2h        ;/
SFR_IO_timer4_lsb       equ 0B3h        ;\slower timer (4x slower than above)
SFR_IO_timer4_msb       equ 0B4h        ;/
SFR_IO_timer34_stat     equ 0B5h     ;NOT R/W ;03
SFR_IO_timer34_ctrl     equ 0B6h     ;bit2-7:NOT R/W
 ;unused                equ 0B7h     ;NOT R/W ;00
SFR_IO_ipc              equ 0B8h    ;<-- used     ;bit7:NOT R/W
SFR_IO_watchdog_config1 equ 0B9h     ;NOT R/W ;03 !  ;\  <-- watchdog config 1                ;\
SFR_IO_watchdog_enable  equ 0BAh     ;NOT R/W ;00    ;   <-- watchdog on/off                  ;
SFR_IO_watchdog_reload  equ 0BBh     ;NOT R/W ;00    ;   <-- watchdog reload                  ; watchdog ?
SFR_IO_watchdog_config2 equ 0BCh     ;NOT R/W ;FF !  ;   <-- watchdog config 2                ;
SFR_IO_watchdog_config3 equ 0BDh     ;NOT R/W ;8F !  ;   <-- watchdog config 3                ;
SFR_IO_watchdog_unlock  equ 0BEh     ;NOT R/W ;00    ;/  <-- watchdog lock/unlock accesses    ;/
 ;unused                equ 0BFh     ;NOT R/W ;00
 ;unused                equ 0C0h     ;NOT R/W ;00
 ;unused                equ 0C1h     ;NOT R/W ;00
 ;unused                equ 0C2h     ;NOT R/W ;00
 ;unused                equ 0C3h     ;NOT R/W ;00
 ;unused                equ 0C4h     ;NOT R/W ;00
 ;unused                equ 0C5h     ;NOT R/W ;00
SFR_IO_memory_system    equ 0C6h  ;DANGER ;spi flash/osd memory system?
 ;unused                equ 0C7h
SFR_IO_baudrate_control equ 0C8h  ;sio/baudrate control? ;aka 8052 timer2_control
 ;unused                equ 0C9h     ;NOT R/W ;00
SFR_IO_baudrate_lsb     equ 0CAh    ;\   baudrate.lsb    ;aka 8052 timer2_reloadcapture_lsb
SFR_IO_baudrate_msb     equ 0CBh    ;/   baudrate.msb    ;aka 8052 timer2_reloadcapture_msb
 ;unused                equ 0CCh     ;NOT R/W ;Fx  ;(R)?  ;<-- some status? (changes automatically)
 ;unused                equ 0CDh     ;NOT R/W ;FF
 ;unused                equ 0CEh     ;NOT R/W ;00
 ;unused                equ 0CFh     ;NOT R/W ;00
SFR_CPU_psw             equ 0D0h
 ;unused                equ 0D1h     ;NOT R/W ;00
 ;unused                equ 0D2h              ;00
 ;unused                equ 0D3h              ;00
 ;unused                equ 0D4h              ;00
 ;unused                equ 0D5h              ;00
 ;unused                equ 0D6h     ;NOT R/W ;00
 ;unused                equ 0D7h     ;NOT R/W ;00
 ;unused                equ 0D8h     ;bit0-2,6:NOT R/W
 ;unused                equ 0D9h     ;NOT R/W ;\
 ;unused                equ 0DAh     ;NOT R/W ;
 ;unused                equ 0DBh     ;NOT R/W ;
 ;unused                equ 0DCh     ;NOT R/W ; 00h-filled
 ;unused                equ 0DDh     ;NOT R/W ;
 ;unused                equ 0DEh     ;NOT R/W ;
 ;unused                equ 0DFh     ;NOT R/W ;/
SFR_CPU_a               equ 0E0h
 ;unused                equ 0E1h     ;NOT R/W ;FF
 ;unused                equ 0E2h     ;NOT R/W ;FF
 ;unused                equ 0E3h     ;NOT R/W ;FF
SFR_IO_IR_data          equ 0E4h     ;NOT R/W ;FF
SFR_IO_IR_flags         equ 0E5h     ;NOT R/W ;04
 ;unused                equ 0E6h     ;NOT R/W ;00
 ;unused                equ 0E7h     ;NOT R/W ;00
SFR_IO_IEC2             equ 0E8h  ;interrupt enable flags
SFR_IO_PORT0_MODE_A     equ 0E9h  ;-PORT0 special mode  ;bit7,6=PWM   ... bit0,1,2=ADC  ... bit3=REMOTE
 ;unused   1_MODE_A ?   equ 0EAh            ;also mode?
 ;unused   2_MODE_A ?   equ 0EBh            ;also mode?
SFR_IO_PORT3_MODE_A     equ 0ECh  ;-PORT3 special mode  ;bit7,6,5=PWM
SFR_IO_PORT0_MODE_B     equ 0EDh  ;-PORT0 special mode  ;bit7,6=PWM   ... bit0,1,2=ADC  ... bit3=REMOTE
 ;unused   1_MODE_B ?   equ 0FEh            ;also mode?
 ;unused   2_MODE_B ?   equ 0EFh            ;also mode?
SFR_CPU_b               equ 0F0h
 ;unused                equ 0F1h     ;NOT R/W ;\
 ;unused                equ 0F2h     ;NOT R/W ; 00h-filled
 ;unused                equ 0F3h     ;NOT R/W ;/
SFR_IO_PORT3_MODE_B     equ 0F4h  ;-PORT3 special mode  ;bit7,6,5=PWM
 ;unused                equ 0F5h      ;bit1-7:NOT R/W
 ;unused                equ 0F6h     ;NOT R/W ;\00h-filled
 ;unused                equ 0F7h     ;NOT R/W ;/
SFR_IO_xxxF8h           equ 0F8h   ;-four flags  ;bit5-7:NOT R/W
 ;unused                equ 0F9h     ;NOT R/W ;\
 ;unused                equ 0FAh     ;NOT R/W ;
 ;unused                equ 0FBh     ;NOT R/W ;
 ;unused                equ 0FCh     ;NOT R/W ; 00h-filled
 ;unused                equ 0FDh     ;NOT R/W ;
 ;unused                equ 0FEh     ;NOT R/W ;
 ;unused                equ 0FFh     ;NOT R/W ;/
;---and bits...
;[SFR_IO_baudrate_control].2      ;-sio/baudrate control?
;[SFR_IO_IEC2].0           ;\
;[SFR_IO_IEC2].1           ; cleared at init
;[SFR_IO_IEC2].2           ;
;[SFR_IO_IEC2].3           ;/
;[SFR_IO_xxxF8h].0         ;\
;[SFR_IO_xxxF8h].1 ;<-SET! ; cleared at init (except pct1: set at init)
;[SFR_IO_xxxF8h].2         ;
;[SFR_IO_xxxF8h].3         ;/
;------------------
;:----------------- code
;------------------
.rom
org   0
;------------------
;below vectors are for P8xCE558 (AMT630A is somewhat different)
;  addr     prio  name    expl
;  0000h    0     RESET   Reset
;  0003h    1     X0      External Interrupt 0
;  000Bh    4     T0      Timer 0 Overflow
;  0013h    7     X1/SEC  External Interrupt 1 or Seconds Interrupt
;  001Bh    10    T1      Timer 1 Overflow
;  0023h    13    S0      SIO0 (UART/RS232) Send or Receive
;  002Bh    2     S1      SIO1 (I2C)
;  0033h    5     CT0     External Interrupt 2 with Timer 2 Capture 0 ;P8xCE558 only (not 8031/8051)
;  003Bh    8     CT1     External Interrupt 3 with Timer 2 Capture 1 ;P8xCE558 only (not 8031/8051)
;  0043h    11    CT2     External Interrupt 4 with Timer 2 Capture 2 ;P8xCE558 only (not 8031/8051)
;  004Bh    14    CT3     External Interrupt 5 with Timer 2 Capture 3 ;P8xCE558 only (not 8031/8051)
;  0053h    3     ADC     ADC Completion
;  005Bh    6     CM0     Timer 2 Compare 0
;  0063h    9     CM1     Timer 2 Compare 1
;  006Bh    12    CM2     Timer 2 Compare 2
;  0073h    15    T2      Timer 2 Overflow
;------------------
;HARDWARE VECTOR (reset)
.errif $<>0000h
warmboot_entry:
 jmp  reset_entrypoint
 defs 0003h-$
;------------------

.comment


;HARDWARE VECTOR (external interrupt 0) (infrared REMOTE)
.errif $<>0003h
 jmp  firm_irq_0003h_ext_int0_infrared
 defs 000bh-$
;------------------
;HARDWARE VECTOR (timer 0 overflow)
.errif $<>000Bh
 jmp  firm_irq_000Bh_timer_0_overflow          ;--> just reload
 defs 0013h-$
;------------------
;HARDWARE VECTOR (external interrupt 1) (unknown/unused connection?)
;.errif $<>0013h
;jmp  ext_int1
 defs 001bh-$
;------------------
;HARDWARE VECTOR (timer 1 overflow)
.errif $<>001Bh
 jmp  firm_irq_001Bh_timer_1_overflow          ;------------>
 defs 0023h-$
;------------------
;HARDWARE VECTOR (rs232 serial port)
;.errif $<>0023h
 defs 002bh-$
;------------------
;HARDWARE VECTOR (timer 2 overflow) (8052)
;.errif $<>002Bh
 defs 0033h-$
;------------------
;HARDWARE VECTOR (?)
;.errif $<>0033h
 defs 003bh-$
;------------------
;HARDWARE VECTOR (?)
;.errif $<>003Bh
 defs 0043h-$
;------------------
;HARDWARE VECTOR (ADC analog input)
.errif $<>0043h
 jmp  firm_irq_0043h_adc_keypad
 defs 004bh-$
;------------------
;HARDWARE VECTOR ?
.errif $<>004Bh
 jmp  firm_irq_004Bh_whatever_91h_5_ack
 defs 0053h-$
;------------------
;HARDWARE VECTOR ?
.errif $<>0053h
 jmp  firm_irq_0053h_whatever_91h_6_ack
 defs 005bh-$
;------------------
;HARDWARE VECTOR ?
.errif $<>005Bh
 jmp  firm_irq_005Bh_framerate
;------------------
;HARDWARE VECTOR ?
.errif $<>0063h
 jmp  firm_irq_0063h_timer34
.comment

.rept 13  +3      ;HARDWARE VECTOR's 0003h..0063h (plus 3 extra, if any)
 push a
 push b
 mov  a,(xram_irq_vectors+($/8)*2) and 0ffh
 ajmp irq_vector_a
.endm
;;;.errif $<>0063h  ;ensure above vectors at 0003h..005Bh, 8 bytes each
;------------------
irq_vector_a:
 ;in: push a
 ;in: push b
 ;in: mov  a,(xram_irq_vectors+($/8)*2) and 0ffh
 push psw
 push dpl
 push dph
 mov  dph,(xram_irq_vectors)/100h
 mov  dpl,a
 movx a,[dptr] ;msb
 mov  b,a      ;msb
 inc  dptr
 movx a,[dptr] ;lsb
 mov  dpl,a    ;lsb
 mov  dph,b    ;msb
 call jmp_dptr
 pop  dph
 pop  dpl
 pop  psw
 pop  b
 pop  a
 reti
;------------------
set_irq_vector_a_to_dptr:   ;in: a=0003h..0063h, dptr=code.addr
 call firm_swap_dptr_vs_r1r0
 mov  dptr,xram_irq_vectors
 and  a,0f8h
 ror  a
 ror  a
 add  a,dpl
 mov  dpl,a
;no carry to dph handled here (shouldn't cross 100h boundary)
 mov  a,r1
 movx [dptr],a   ;msb
 inc  dptr
 mov  a,r0
 movx [dptr],a   ;lsb
 ret
;------------------
jmp_r2r1:    ;in: r3r2r1 (r3=area/ignored, must be always CODE area)
 mov  dph,r2
 mov  dpl,r1
;- - - - - --------
jmp_dptr:    ;in: dptr
 clr  a
 jmp  a+dptr
;------------------
firm_irq_0043h_adc_keypad:
;push a
;push dph
;push dpl
.if with_keypad_irq
 push r0(0)
 push r1(0)
 mov  dptr,IO_ADC_input_0_msb           ;\
 movx a,[dptr]                          ;
 mov  r1,a      ;adc.msb                ; read analog value
 mov  dptr,IO_ADC_input_0_lsb           ;
 movx a,[dptr]                          ;
 mov  r0,a      ;adc.lsb                ;/
 mov  dptr,xram_analog_keypad_index     ;\
 movx a,[dptr]                          ;
 inc  a         ;index+1                ;
 jne  a,num_keypad_readings,$+3  ;CMP   ; raise index
 jc   @@index_inrange                   ;
 clr  a         ;wrap index             ;
@@index_inrange:                        ;
 movx [dptr],a                          ;/
 mov  dptr,xram_analog_keypad_values    ;\
 rol  a         ;index*2                ;
 add  a,dpl     ;index*2+base           ;
 mov  dpl,a                             ; store analog value at index
 mov  a,r1      ;adc.msb                ;
 movx [dptr],a                          ;
 inc  dptr                              ;
 mov  a,r0      ;adc.lsb                ;
 movx [dptr],a                          ;/
 pop  r1(0)
 pop  r0(0)
.endif
;- - -
 and  [SFR_IO_xxx91h],0EFh   ;not 10h  ;bit4=0    ;-ack ADC to CPU
 mov  dptr,IO_ADC_status_lsb            ;\
 clr  a                                 ;
 movx [dptr],a     ;=00h                ; ack ADC to itself?
 inc  dptr ;=IO_ADC_status_msb          ;
 movx [dptr],a     ;=00h                ;/
;pop  dpl
;pop  dph
;pop  a
 ret
;------------------
firm_irq_004Bh_whatever_91h_5_ack:
 and  [SFR_IO_xxx91h],0DFh   ;not 20h  ;bit5=0
 ret
;------------------
firm_irq_0053h_whatever_91h_6_ack:
 and  [SFR_IO_xxx91h],0BFh   ;not 40h  ;bit6=0
 ret
;------------------
firm_irq_005Bh_framerate:
 inc  [sys_random+0]
 mov  [sys_vblank_flag],1
 and  [SFR_IO_xxx91h],7Fh    ;not 80h  ;bit7=0
 ret
;------------------
firm_irq_000Bh_timer_0_overflow:   ;just reload the timer...
 clr  tr0         ;XXXsfr
 mov  [SFR_IO_timer0_msb],0FBh          ;\FB9Fh aka -461h (-1121)       ;\Timer0
 mov  [SFR_IO_timer0_lsb],9Fh           ;/                              ;/
 set  tr0         ;XXXsfr
 ret
;------------------
firm_wait_vblank:
 push a
 push dpl
 push dph
 mov  dptr,IO_PLL_12h_used              ;\
 movx a,[dptr]                          ; can't wait if pll/av/dotclk is off
 jz   a.2,@@pll_is_off                  ;/
 jz   [SFR_IO_iec].7,@@irq_less   ;master.irq.enable
 jz   [SFR_IO_IEC2].3,@@irq_less  ;framerate.irq.enable
;- - -
 mov  a,[sys_vblank_flag]
 jnz  a,@@irq_done
@@irq_wait:
 mov  a,[SFR_IO_PCON]   ;\
 or   a,1   ;halt/idle  ; halt CPU till IRQ (doesn't actually save power)
 mov  [SFR_IO_PCON],a   ;/
 mov  a,[sys_vblank_flag]
 jz   a,@@irq_wait
@@irq_done:
@@pll_is_off:
 mov  [sys_vblank_flag],0
 pop  dph
 pop  dpl
 pop  a
 ret
;---
@@irq_less:
@@irq_less_wait:
 mov  a,[SFR_IO_xxx91h]
 jz   a.7,@@irq_less_wait
 and  [SFR_IO_xxx91h],not 80h
 sjmp @@irq_done
;------------------
firm_timer_adjust_artifacts:  ;out: [iram_tmp__24h]
 mov  dptr,IO_AV_stat_signal_detect                          ;\
 movx a,[dptr]                                               ;
 and  a,0Fh                                                  ;
 mov  [iram_tmp__23h],a  ;copied lsbs of IO_AV_stat_signal_detect ;/
 mov  dptr,IO_AV_stat_detect_2                               ;\
 movx a,[dptr]                                               ;
 mov  [iram_tmp__24h],a  ;copied byte of IO_AV_stat_detect_2 ;/
;- - -
 mov  dptr,xram_old_AV_stat_signal_detect                 ;\
 movx a,[dptr]             ;<-- old (initially  FFh)      ;
 mov  r7,a            ;<--                                ;
;now XOR by copied lsbs of IO_AV_stat_signal_detect       ;
 xor  a,[iram_tmp__23h]    ;<--                           ;
 jz   a,@@artifacts_stable ;--> same (have "stable signal);/
;- - -
;now APPLY copied lsbs of IO_AV_stat_signal_detect      ;\
 mov  a,[iram_tmp__23h]                                 ;
 movx [dptr],a  ;[xram_old_AV_stat_signal_detect]=a     ;/
 clr  a                                                 ;\
 mov  dptr,xram_irq_artifacts_offhold                   ;
 movx [dptr],a             ;<-- reload offhold          ;/
 sjmp @@artifacts_done     ;----> and skip artifacts stuff...
;---
@@artifacts_stable:
 mov  dptr,xram_irq_artifacts_offhold   ;\                  ;\
 movx a,[dptr]                          ;                   ;
 clr  c                                 ;                   ;
 sbc  a,14h                             ;                   ;
 jnc  @@artifacts_done      ;already 20 ;                   ;
 movx a,[dptr]                          ;                   ;
 inc  a                                 ;                   ;
 movx [dptr],a                          ;                   ;
 xor  a,14h                             ;                   ;
 jnz  a,@@artifacts_done    ;notyet 20  ;/                  ;
 mov  a,r7        ;<--                  ;\                  ;
 dec  a                                 ;                   ;
 jz   a,@@artifacts_00h                 ;                   ;
 add  a,0FCh                            ;                   ;
 jz   a,@@artifacts_02h                 ;                   ;
 add  a,05h                             ;                   ;
 jnz  a,@@artifacts_done     ;--> uh    ;                   ;
 mov  dptr,IO_AV_ctrl_artifacts         ;                   ;
 mov  a,06h                             ;                   ;
 sjmp @@artifacts_06h                   ;                   ;
;---                                    ;                   ;
@@artifacts_00h:                        ;                   ;
 mov  dptr,IO_AV_ctrl_artifacts         ;                   ;
 clr  a                                 ;                   ;
@@artifacts_06h:  ;<-- in: a=06h        ;                   ;
 ;with dptr=IO_AV_ctrl_artifacts        ;                   ;
 movx [dptr],a    ;=00h, or 06h         ;/                  ;
 mov  dptr,IO_AV_ctrl_whatever_1        ;\                  ;
 movx a,[dptr]                          ;                   ;
 or   a,02h     ;set bit1               ;                   ;
 movx [dptr],a                          ;/                  ;
 sjmp @@artifacts_done                                      ;
;---                                                        ;
@@artifacts_02h:                                            ;
 mov  dptr,IO_AV_ctrl_whatever_1        ;\                  ;
 movx a,[dptr]                          ;                   ;
 and  a,0FDh    ;clr bit1               ;                   ;
 movx [dptr],a                          ;/                  ;
 mov  dptr,IO_AV_ctrl_artifacts ;\                          ;
 mov  a,02h                     ;                           ;
 movx [dptr],a                  ;/                          ;
@@artifacts_done:                                           ;/
 ret
;------------------
firm_timer_adjust_sharpness:    ;in: [iram_tmp__24h]
 mov  dptr,xram_old_AV_stat_detect_2
 movx a,[dptr]
 xor  a,[iram_tmp__24h]  ;copied byte of IO_AV_stat_detect_2
 jz   a,@@sharpness_stable   ;---> same (have "stable" signal)
 mov  a,[iram_tmp__24h]  ;copied byte of IO_AV_stat_detect_2 ;\apply new
 movx [dptr],a    ;[xram_old_AV_stat_detect_2]=a             ;/
 clr  a                                 ;\
 mov  dptr,xram_irq_sharpness_offhold   ; reload offhold
 movx [dptr],a                          ;/
 sjmp @@sharpness_done
;---
@@sharpness_stable:
 mov  dptr,xram_irq_sharpness_offhold   ;\
 movx a,[dptr]                          ;
 clr  c                                 ;
 sbc  a,0Ah                             ; sharpness offhold
 jnc  @@sharpness_done     ;already 0Ah ;
 movx a,[dptr]                          ;
 inc  a                    ;raise       ;
 movx [dptr],a                          ;
 xor  a,0Ah                             ;
 jnz  a,@@sharpness_done   ;notyet 0Ah  ;/
 mov  dptr,IO_AV_stat_detect_2          ;\
 movx a,[dptr]  ;read                   ;
 jnz  a.4,@@sharpness_clear_bit1        ;
 movx a,[dptr]  ;re-read?               ;
 jnz  a.2,@@sharpness_clear_bit1        ;
 movx a,[dptr]  ;re-read?               ;
 jnz  a.5,@@sharpness_clear_bit1        ;
 movx a,[dptr]  ;re-read?               ;
 jz   a.3,@@sharpness_set_bit1 ;--> set ;
@@sharpness_clear_bit1:                 ;/
 mov  dptr,IO_LCD_sharpness_or_so       ;\
 movx a,[dptr]                          ;
 and  a,0FDh     ;bit1=0                ;
 movx [dptr],a                          ;/
 sjmp @@sharpness_done
;---
@@sharpness_set_bit1:
 mov  dptr,IO_LCD_sharpness_or_so       ;\
 movx a,[dptr]                          ;
 or   a,02h      ;bit1=1                ;
 movx [dptr],a                          ;/
@@sharpness_done:
 ret
;------------------
firm_timer_adjust_sensitivity:
 mov  dptr,IO_AV_stat_detect_0                              ;\
 movx a,[dptr]                                              ;
 and  a,02h                                                 ;
 jz   a,@@sensitivity_done  ;skip                           ;
;- - -                                                      ;
 mov  dptr,xram_irq_sensitivity_offhold                     ;
 movx a,[dptr]                  ;\                          ;
 inc  a                         ; detect each 100th time    ;
 movx [dptr],a                  ; (or, with 256-step        ;
 mov  b,64h  ;100 decimal       ; wrap, it's actually       ;
 div  a,b                       ; each 100th,100th,64th)    ;
 mov  a,b                       ;                           ;
 jnz  a,@@sensitivity_done      ;/                          ;
 mov  dptr,IO_AV_stat_sensitivity_msb          ;\           ;
 movx a,[dptr]                                 ;            ;
                                               ; read stat  ;
                                               ; sensitivity;
                                               ; (aka signal;
 mov  r1,a                   ;sens.msb         ; strength   ;
 inc  dptr ;=IO_AV_stat_sensitivity_lsb        ; or so)     ;
 movx a,[dptr]                                 ;            ;
 mov  r0,a                   ;sens.lsb         ;/           ;
;- - -                                                      ;
@@sensitivity_mode equ 0Bh  ;const.flags (aka "r5" in original firmware)
.if @@sensitivity_mode AND 01h
  ;- - - MODE 1...                                            ;
   mov  dptr,IO_AV_ctrl_sensitivity_0     ;\                  ;
   movx a,[dptr]                          ;                   ;
   xor  a,05h                             ;                   ;
   jnz  a,@@sensitivity_done              ;/                  ;
   mov  dptr,IO_AV_ctrl_sensitivity_1     ;\                  ;
   movx a,[dptr]                          ; check if B5h      ;
   xor  a,0B5h                            ;                   ;
   jnz  a,@@sensitivity_done              ;/                  ;
   clr  c                                                     ;
   mov  a,r0          ;sens.lsb   ;\                          ;
   sbc  a,0A0h                    ; 01A0h (416 decimal)       ;
   mov  a,r1          ;sens.msb   ;                           ;
   sbc  a,01h                     ;                           ;
   jnc  @@sensitivity_done        ;/                          ;
    ;TOO SMALL --> change sensitivity?                        ;
  ;with dptr=IO_AV_ctrl_sensitivity_1     ;\                  ;
   mov  a,0B6h                            ;                   ;
   movx [dptr],a                          ;/                  ;
   mov  dptr,IO_AV_ctrl_sensitivity_0     ;\                  ;
   mov  a,09h                             ;                   ;
   movx [dptr],a                          ;/                  ;
.else
  ;--- MODE 0...                                              ;
  .errif 1  ;this shouldn't be used...                        ;
  @@sensitivity_mode_0:                                       ;
   mov  dptr,IO_AV_ctrl_sensitivity_0     ;\check if already  ;
   movx a,[dptr]                          ; ...               ;
   jnz  a,@@sensitivity_is_okay           ;/                  ;
   set  c     ;<--                ;\                          ;
   mov  a,r0          ;sens.lsb   ;                           ;
   sbc  a,00h                     ; 0601h (1537 decimal)      ;
   mov  a,r1          ;sens.msb   ;                           ;
   sbc  a,06h                     ;                           ;
   jnc  @@sensitivity_is_okay     ;/                          ;
     ;TOO SMALL --> change sensitivity?                       ;
  ;with dptr=IO_AV_ctrl_sensitivity_0     ;\                  ;
   mov  a,05h                             ; CHANGE            ;
   movx [dptr],a                          ;/                  ;
   mov  r7,0C8h                           ;\                  ;
   mov  r6,00h                            ; delay 200 (weird) ;
   call slow_weird_delay_r6r7             ;/                  ;
  @@sensitivity_is_okay:                                      ;
   mov  dptr,IO_AV_ctrl_sensitivity_0 ;\                      ;
   movx a,[dptr]                      ; check if 05h          ;
   jne  a,05h,@@sensitivity_done      ;/                      ;
   clr  c                         ;\                          ;
   mov  a,r0          ;sens.lsb   ;                           ;
   sbc  a,0FFh                    ; 0FFFh (4095 decimal)      ;
   mov  a,r1          ;sens.msb   ; (max, aka NoSignal)       ;
   sbc  a,0Fh                     ;                           ;
   jc   @@sensitivity_done        ;/                          ;
     ;NONE AT ALL --> set heavy max sensitivity?              ;
  ;with dptr=IO_AV_ctrl_sensitivity_0     ;\                  ;
   clr  a                                 ; CHANGE            ;
   movx [dptr],a                          ;/                  ;
   mov  r7,0C8h                           ;\                  ;
   mov  r6,00h                            ; delay 200 (weird) ;
   call slow_weird_delay_r6r7             ;/                  ;
.endif
@@sensitivity_done:                                         ;/
 ret
;------------------
firm_timer_adjust_boldness:
 mov  dptr,IO_AV_stat_detect_1          ;\  ;<-- used ONLY  ;\
 movx a,[dptr]                          ;        here       ;
 mov  dptr,IO_50HZ_control_lsb          ;                   ;
 jz   a.0,@@boldness_this               ;/                  ;
;- - -                                                      ;
 movx a,[dptr]   ;[IO_50HZ_control_lsb] ;\                  ;
 or   a,10h      ;bit4=1                ;                   ;
 movx [dptr],a   ;[IO_50HZ_control_lsb] ;/                  ;
 mov  dptr,IO_60HZ_control_mid          ;\                  ;
 movx a,[dptr]                          ;                   ;
 or   a,10h      ;bit4=1 ;aka bit12 ??  ;                   ;
 movx [dptr],a                          ;/                  ;
 mov  dptr,IO_60HZ_boldness_contrast    ;\                  ;
 clr  a          ;num=00h               ;/                  ;
 sjmp @@boldness_finish                                     ;
;---                                                        ;
@@boldness_this:                                            ;
 movx a,[dptr]   ;[IO_50HZ_control_lsb] ;\                  ;
 and  a,0EFh     ;bit4=0                ;                   ;
 movx [dptr],a   ;[IO_50HZ_control_lsb] ;/                  ;
 mov  dptr,IO_60HZ_control_mid          ;\                  ;
 movx a,[dptr]                          ;                   ;
 and  a,0EFh     ;bit4=0 ;aka bit12 ??  ;                   ;
 movx [dptr],a                          ;/                  ;
 mov  dptr,IO_60HZ_boldness_contrast    ;\                  ;
 mov  a,02h      ;num=02h               ;/                  ;
;- - -                                                      ;
@@boldness_finish:                                          ;
;with dptr=IO_60HZ_boldness_contrast    ;\                  ;
 movx [dptr],a   ;=00h or 02h           ;/                  ;
 mov  dptr,IO_50HZ_boldness_contrast    ;\                  ;
 movx [dptr],a   ;=00h or 02h           ;/                  ;/
 ret
;------------------
firm_timer_coarse_enter:
;;@@enter_coarse_mode:   ;COARSE (instead of ARTIFACTS/SHARPNESS)
 clr  a                                 ;\                  ;\
 mov  dptr,xram_irq_coarse_offhold      ;                   ;
 movx [dptr],a                          ;/                  ;
 mov  dptr,IO_AV_ctrl_whatever_2        ;\                  ;
 movx a,[dptr]                          ;                   ;
 or   a,40h                             ;                   ;
 movx [dptr],a                          ;/                  ;/
 ret
;------------------
firm_timer_coarse_release:


        mov  dptr,xram_sett_pal_ntsc    ;XXX tweak_pal60
        movx a,[dptr]
        jnz  a,@@coarse_dont_release  ;avoid heavy picture roll in PAL60



 mov  dptr,xram_irq_coarse_offhold                          ;\
 movx a,[dptr]                                              ;
 clr  c                                                     ; REALEASE COARSE
 sbc  a,0FAh  ;250 decimal                                  ; after offhold...
 jnc  @@coarse_dont_release         ;already 250            ;
 movx a,[dptr]                                              ;
 inc  a                             ;raise                  ;
 movx [dptr],a                                              ;
 jne  a,0FAh,@@coarse_dont_release  ;notyet 250             ;
 mov  dptr,IO_AV_ctrl_whatever_2                            ;
 movx a,[dptr]                                              ;
 and  a,0BFh                     ;<----                     ;
 movx [dptr],a                                              ;
@@coarse_dont_release:                                      ;/
 ret
;------------------
firm_timer_detect_framerate:
 mov  dptr,IO_AV_stat_detect_0          ;\
 movx a,[dptr]                          ;
 and  a,06h                             ;
 xor  a,06h                             ;
 jz   a,@@signal_present                ; want VALID signal?
 mov  dptr,xram_new_detected_video      ;
 movx a,[dptr]  ;check if FFh=none?     ;
 jne  a,0FFh,@@different  ;---> ;diff   ;
@@signal_present:                       ;/
 mov  dptr,IO_AV_stat_framerate_flag            ;\
 movx a,[dptr]                                  ;
 and  a,04h  ;bit2 (0=NTSC/60, 1=PAL/50)        ; want SAME signal
 xchg a,[iram_old_AV_framerate]    ;old=new     ;
 jne  a,[iram_old_AV_framerate],@@different     ;/
 mov  dptr,xram_palntsc_same_counter            ;\
 movx a,[dptr]        ;num.same                 ;
 clr  c                                         ;
 sbc  a,14h                                     ; want 20xSAME
 jnc  @@done                   ;already         ;
 movx a,[dptr]                                  ;
 inc  a    ;[xram_palntsc_same_counter]         ;
 movx [dptr],a                                  ;
 jne  a,14h,@@done             ;notyet          ;/
;- - -               ;NTSC/PAL ;now!
 mov  a,[iram_old_AV_framerate]         ;\apply detected bit2 (0=NTSC/60, 1=PAL/50)
 mov  dptr,xram_new_detected_video   ;\ ;
 movx [dptr],a       ;<-- apply      ;/ ;/
 sjmp @@done
;---
@@different:
 mov  dptr,xram_palntsc_same_counter    ;\
 clr  a                                 ; reset SAME counter
 movx [dptr],a                          ;/
@@done:
 ret
;------------------
;:----------------- TIMER 1
;------------------
firm_irq_001Bh_timer_1_overflow:
;push a
;push b
;push dpl
;push dph
;push psw
 mov  psw,00h
 push r0(0)
 push r1(0)
 push r2(0)
 push r3(0)
 push r4(0)
 push r5(0)
 push r6(0)
 push r7(0)
 clr  tr1         ;XXXsfr                                       ;\
 mov  [SFR_IO_timer1_msb],0D8h  ;\D8EFh aka -2711h (-10001)     ; reload
 mov  [SFR_IO_timer1_lsb],0EFh  ;/                              ; Timer1 (27MHz/12/10000 = 225Hz = ca. 4.444ms rate)
 set  tr1         ;XXXsfr                                       ;/
 inc  [iram_timer1_irq_counter]         ;-counter up
;- - -
 mov  dptr,IO_AV_stat_detect_0  ;\
 movx a,[dptr]                  ;
 and  a,02h     ;bit1           ;
 jnz  a,@@dont_enter_coarse     ;/
 call firm_timer_coarse_enter  ;when bad, goto COARSE mode
 sjmp @@artifacts_sharpness_done
@@dont_enter_coarse:
 call firm_timer_adjust_artifacts   ;out: [iram_tmp__24h]
 call firm_timer_coarse_release
 call firm_timer_adjust_sharpness   ;in: [iram_tmp__24h]
@@artifacts_sharpness_done:
 call firm_timer_adjust_sensitivity
 call firm_timer_adjust_boldness
;- - -
 mov  dptr,IO_VIDEO_something_5         ;\
 clr  a                                 ;
 movx [dptr],a                          ;/
;- - - - - - -
 mov  a,[iram_timer1_irq_counter]       ;\
 and  a,03h                             ;
 jnz  a,@@skip_framerate                ; check framerate
 call firm_timer_detect_framerate       ; and apply tint for pal/ntsc
 call apply_tint                        ;
@@skip_framerate:                       ;/
 mov  a,[iram_timer1_irq_counter]       ;\
 and  a,0fh                             ;
 jnz  a,@@skip_input_select             ; select AV1/AV2 input
 call input_selector                    ;
@@skip_input_select:                    ;/
 pop  r7(0)
 pop  r6(0)
 pop  r5(0)
 pop  r4(0)
 pop  r3(0)
 pop  r2(0)
 pop  r1(0)
 pop  r0(0)
;pop  psw
;pop  dph
;pop  dpl
;pop  b
;pop  a
 ret
;------------------
input_selector:
 mov  dptr,IO_PLL_12h_used              ;\
 movx a,[dptr]                          ;
 jnz  a.2,@@have_av_pll_powered         ;/
;- - -
;@@av_pll_is_powered_down:
;(primary status bit in IO_AV_stat_detect_0.bit1 doesn't work in power-down
;state, however, the secondary status bit in IO_AV_stat_signal_detect.bit6
;does work, and that bit can tested in standby loop --- to map meaningful
;info to that bit, below code does DESELECT the DESIRED input; or TOGGLEs
;between both inputs when BOTH ARE DESIRED).
 mov  dptr,xram_sett_input              ;\get user selection
 movx a,[dptr]                          ;/
 jnz  a.1,@@force_non_primary           ;-when forcing AV1 Only or AV2 Only
 sjmp @@toggle_to_other                 ;-when wanting BOTH signals
;---
@@have_av_pll_powered:
 mov  dptr,IO_AV_stat_signal_detect     ;\
 movx a,[dptr]                          ; get signal detect bits
 mov  b,a                               ;/
 mov  dptr,IO_AV_stat_detect_0          ;\
 movx a,[dptr]                          ; replace bit4 by another/better bit
 mov  c,a.1   ;\this better for C64     ; (needed for C64 only)
 mov  b.4,c   ;/                        ;/
 mov  dptr,xram_sett_input              ;\get user selection
 movx a,[dptr]                          ;/
 jnz  a.1,@@force_primary               ;-when forcing AV1 Only or AV2 Only
 jz   b.6,@@stay_current                ;-when no signal on secondary pin
 jz   b.4,@@toggle_to_other             ;-when no signal on primary pin
 sjmp @@force_primary                   ;-when signals on BOTH pins
;---
@@toggle_to_other:
 mov  dptr,xram_curr_input              ;\
 movx a,[dptr]                          ;/
@@force_non_primary:
 xor  a,1
@@force_primary:
 and  a,01h
 mov  dptr,xram_curr_input              ;\
 movx [dptr],a                          ;/
 rol  a
 call apply_av_input_a
@@stay_current:
 ret
;------------------
;:----------------- FLASH code (detect)
;------------------
firm_flash_wait:
general_flash_wait:  ;XXXXX
@@wait_lop:                     ;\
 mov  dptr,IO_SPI_status_ready  ; wait
 movx a,[dptr]                  ;
 jz   a.7,@@wait_lop            ;/
 ret
;------------------
firm_flash_clear:
 call firm_flash_wait                   ;-wait
 mov  dptr,IO_SPI_ready_flags           ;\
 clr  a                                 ;
 movx [dptr],a                          ;/
 inc  dptr ;=IO_SPI_kick_stop_reset     ;\
 mov  a,80h                             ;
 movx [dptr],a                          ;/
 ret
;------------------
firm_flash_set_addr_r2r1r0:
 mov  dptr,IO_SPI_flash_addr_lsb        ;\
 mov  a,r0                              ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_SPI_flash_addr_mid      ;
 mov  a,r1                              ; flash.addr
 movx [dptr],a                          ;
 inc  dptr ;=IO_SPI_flash_addr_msb      ;
 mov  a,r2                              ;
 movx [dptr],a                          ;/
 ret
;------------------
firm_flash_kick_r0:
 mov  dptr,IO_SPI_transfer_mode         ;\
 mov  a,r0                              ; FlashCmd
 movx [dptr],a                          ;/
 mov  dptr,IO_SPI_ready_flags           ;\
@@wait_lop:                             ;
 movx a,[dptr]                          ; wait
 and  a,r0                              ;
 jz   a,@@wait_lop                      ;/
 ret
;------------------
flash_write_enable:
 call firm_flash_clear                  ;-
 mov  dptr,IO_SPI_flash_addr_lsb        ;\
 mov  a,0FFh                            ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_SPI_flash_addr_mid      ; addr=FFFFFFh (dummy)
 movx [dptr],a                          ;
 inc  dptr ;=IO_SPI_flash_addr_msb      ;
 movx [dptr],a                          ;/
 mov  dptr,IO_SPI_command_write         ;\
 mov  a,06h                             ; cmd=WREN
 movx [dptr],a                          ;/
 mov  r0,08h                            ;\FlashCmd08h
 call firm_flash_kick_r0                ;/
 jmp  general_flash_wait                ;-wait
;------------------
flash_set_wprot_to_r0:
 call firm_flash_clear                  ;-
 mov  dptr,IO_SPI_wprot_stat_write      ;\
 mov  a,r0     ;<-- INCOMING PARAM      ; param
 movx [dptr],a                          ;/
 mov  r0,04h                            ;\FlashCmd04h
 call firm_flash_kick_r0                ;/
 jmp  general_flash_wait                ;-wait
;------------------
flash_write_disable:
 call firm_flash_clear                  ;-
 mov  dptr,IO_SPI_flash_addr_lsb        ;\
 mov  a,0FFh                            ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_SPI_flash_addr_mid      ; addr=FFFFFFh (dummy) (uh, why?)
 movx [dptr],a                          ;
 inc  dptr ;=IO_SPI_flash_addr_msb      ;
 movx [dptr],a                          ;/
 mov  dptr,IO_SPI_command_write         ;\
 mov  a,04h                             ; WrDisable (WREN=0)
 movx [dptr],a                          ;/
 mov  r0,08h                            ;\FlashCmd08h
 call firm_flash_kick_r0                ;/
 jmp  general_flash_wait                ;-wait
;------------------
flash_read_write_protect_status_r0:
 call firm_flash_clear                  ;-
 mov  r0,02h                            ;\FlashCmd02h
 call firm_flash_kick_r0                ;/
 mov  dptr,IO_SPI_manual_data_read      ;\
 movx a,[dptr]                          ; MANUAL READ !!!!!
 mov  r0,a                              ;/
 call general_flash_wait                ;-wait
 ret
;------------------
detect_flash_chiptype:
;call flash_get_chip_id_r2r1r0
 ret
;------------------
flash_erase_block_r2r1r0:
 call firm_flash_clear                  ;-
 call firm_flash_set_addr_r2r1r0        ;-set flash addr
 mov  dptr,IO_SPI_command_write         ;\
 mov  a,20h                             ; cmd_erase  (20h=ERASE?)
 movx [dptr],a                          ;/
 mov  r0,08h                            ;\FlashCmd08h
 call firm_flash_kick_r0                ;/
 call general_flash_wait                ;-wait
 ret
;------------------
flash_write_dptr_to_r2r1r0_len_r3:         ;WRITE FLASH (max 100h bytes)
 push dph  ;--> incoming dph
 push dpl  ;--> incoming dpl
 push r0(0)
 call flash_write_enable                        ;-wren
 call flash_erase_block_r2r1r0                  ;-erase
 pop  r0(0)
 pop  dpl  ;<-- incoming dpl
 pop  dph  ;<-- incoming dph
;- - - - - - ------
flash_write_dptr_to_r2r1r0_len_r3_without_erase:  ;WRITE FLASH (max 100h bytes)
 push dph  ;--> incoming dph
 push dpl  ;--> incoming dpl
 call firm_flash_clear                  ;-
 call firm_flash_set_addr_r2r1r0        ;-set flash addr (dest)
 mov  dptr,IO_SPI_dma_ram_addr_lsb      ;\
 pop  a    ;<-- incoming dpl            ;
 movx [dptr],a  ;OUT.ram.lsb            ; CPU.XRAM addr (src)
 inc  dptr ;=IO_SPI_dma_ram_addr_msb    ;
 pop  a    ;<-- incoming dph            ;
 or   a,80h            ;<-- XXXX maybe region=CPU.RAM (vs VRAM), or direction=TO_FLASH ?
 movx [dptr],a                          ;/
 mov  dptr,IO_SPI_dma_length_lsb        ;\
 mov  a,r3                              ;
 dec  a                   ;XXXX MINUS ONE !!!
 movx [dptr],a  ;OUT.len.lsb            ; length (minus 1)
 inc  dptr ;=IO_SPI_dma_length_msb      ;
 clr  a                                 ;
 movx [dptr],a  ;OUT.len.msb            ;/
 mov  r0,80h                            ;\FlashCmd80h
 call firm_flash_kick_r0                ;/
;;; call flash_write_disable               ;-uh, what/why?
 ret
;------------------
flash_dma_upload_font_from_r2r1r0_to_dptr_len_r4r3:   ;FLASH-to-FONT
 clr  ea         ;XXXsfr
 push dph  ;--> incoming dph
 push dpl  ;--> incoming dpl
 call firm_flash_clear                  ;-clear
 or   [SFR_IO_memory_system],08h ;bit3  ;-pause FONT rendering during DMA upload
 call firm_flash_set_addr_r2r1r0        ;-set flash addr (src)
 mov  dptr,IO_SPI_dma_ram_addr_lsb      ;\
 pop  a    ;<-- incoming dpl            ;
 movx [dptr],a                          ; set VRAM.addr (dst)
 inc  dptr ;=IO_SPI_dma_ram_addr_msb    ;
 pop  a    ;<-- incoming dph            ;
 movx [dptr],a                          ;/
 mov  dptr,IO_SPI_dma_length_lsb        ;\
 mov  a,r3                ;len.lsb      ;
 add  a,0FFh                            ;
 movx [dptr],a  ;len.lsb                ; length (minus 1)
 inc  dptr ;=IO_SPI_dma_length_msb      ;
 mov  a,r4                ;len.msb      ;
 adc  a,0FFh                            ;
 movx [dptr],a  ;len.msb                ;/
 mov  r0,40h                            ;\FlashCmd40h
 call firm_flash_kick_r0                ;/
 call firm_flash_wait                   ;-wait
 and  [SFR_IO_memory_system],0F7h ;bit3 ;-resume FONT rendering after DMA upload
 set  ea         ;XXXsfr
 ret
;------------------
flash_read_r2r1r0_to_dptr_len_r3:
 push dpl  ;-->
 push dph  ;-->
 call general_flash_wait                ;-wait
 mov  dptr,IO_SPI_kick_stop_reset       ;\
 mov  a,80h                             ;
 movx [dptr],a                          ;/
@@byte_lop:
 mov  dptr,IO_SPI_ready_flags           ;\
 clr  a                                 ;
 movx [dptr],a                          ;/
 call firm_flash_set_addr_r2r1r0        ;-set flash addr
 push r0(0)
 mov  r0,10h                            ;\FlashCmd10h (original firmware is doing this with TIMEOUT here, don't know why)
 call firm_flash_kick_r0                ;/
 pop  r0(0)
 mov  dptr,IO_SPI_manual_data_read      ;\read DATA manually
 movx a,[dptr]     ;IN.DATA !!!         ;/(via non-DMA)
 pop  dph  ;<--                         ;\
 pop  dpl  ;<--                         ;
 movx [dptr],a                          ; store in XRAM
 inc  dptr                              ;
 push dpl  ;-->                         ;
 push dph  ;-->                         ;/
 inc  r0                                ;\
 jne  r0,00h,@@keep_flash_msbs          ;
 inc  r1                                ; raise flash.addr
 jne  r1,00h,@@keep_flash_msbs          ;
 inc  r2                                ;
@@keep_flash_msbs:                      ;/
 call general_flash_wait                ;-wait
 djnz r3,@@byte_lop                     ;-lop next byte
 pop  dph  ;<--
 pop  dpl  ;<--
 ret
;------------------
flash_get_chip_id_r2r1r0:
 call firm_flash_clear                  ;-
 mov  r0,01h                            ;\FlashCmd01h
 call firm_flash_kick_r0                ;/
 mov  dptr,IO_SPI_chip_id_read_lsb      ;\
 movx a,[dptr]                          ; get byte2 (lsb,maker)
 add  a,a                               ;
 mov  r0,a                              ;/
 mov  dptr,IO_SPI_chip_id_read_mid      ;\
 movx a,[dptr]                          ; get byte1 (mid)
 rcl  a                                 ;
 mov  r1,a                              ;/
 mov  dptr,IO_SPI_chip_id_read_msb      ;\
 movx a,[dptr]                          ; get byte0 (msb)
 rcl  a                                 ;
 mov  r2,a                              ;/
 mov  a,r0                              ;\
 mov  a.0,c                             ; maybe... put carry-out to lsb.bit0?
 mov  r0,a                              ;/
 jmp  general_flash_wait                ;-wait
;------------------
;:----------------- FLASH data (chip types)
;------------------
;.if flash_version<ver11sep2017
; flash_chiptype_list:       ;02h-byte blocks...
;  ;--- +0  +1
;  ;---Wren Erase
;  db   06h,020h  ;-type 0 (used)
;  db   06h,0D7h  ;\
;  db   06h,0D8h  ; type 1-3 (not used, type is fixed=0)
;  db   06h,020h  ;/
;  ;06h = Write Enable (WREN) (for write/erase/writeprotect)
;  ;20h = Erase Sector (4Kbyte)
;  ;D7h = Erase what ?
;  ;D8h = Erase Block (64Kbyte)
;.else ;- - - - - - - - - - - - - - - - - - - - - - - - - - - -
; flash_chiptype_list:       ;0Ch-byte blocks...
;  ;--- +0  +1  +2  +3  +4  +5  +6   +7  +8  +9  +A   +B
;  ;--- ID  Fre Lok Era <--settings_1--> <--settings_2-->
;  db   10h,00h,04h,20h,00h,00h,0E0h,00h,00h,00h,0F0h,00h ;<-- default used when chip.detection.failure (which DOES seem to happen due to some bug)
;  db   11h,24h,18h,20h,00h,01h,0E0h,00h,00h,01h,0F0h,00h ;W25D10 128Kbyte
;  db   12h,28h,0Ch,20h,00h,02h,000h,00h,00h,02h,010h,00h ;W25D20 256Kbyte
;  db   13h,28h,10h,20h,00h,02h,000h,00h,00h,02h,010h,00h ;W25D40 512Kbyte (this chip is being used on existing boards, but... above default seems to be use due to some bug)
;  db   14h,28h,14h,20h,00h,02h,000h,00h,00h,02h,010h,00h ;W25D80 1024Kbyte
;  db   15h,28h,18h,20h,00h,02h,000h,00h,00h,02h,010h,00h
;  db   16h,28h,1Ch,20h,00h,02h,000h,00h,00h,02h,010h,00h
;  db   17h,24h,1Ch,20h,00h,02h,000h,00h,00h,02h,010h,00h
;  db   18h,1Ch,1Ch,20h,00h,02h,000h,00h,00h,02h,010h,00h
;  db   19h,24h,24h,20h,00h,02h,000h,00h,00h,02h,010h,00h
;  db   20h,24h,24h,20h,00h,02h,000h,00h,00h,02h,010h,00h ;?
;.endif
;------------------
;:----------------- GPIO code (non-pwm-mode)
;------------------
;below stuff outputs FIXED (non-PWM) levels on the "PWM" pins...
;---
;pin55  Port3.5    DC_PWM0
;pin56  Port3.6    DC_PWM1   TXD''
;pin57  Port3.7    DC_PWM2   RXD''
;pin58  Port0.7    DC_PWM3   RXD'
;pin59  Port0.6    DC_PWM2'  TXD'
;------------------
firm_set_p07_spi_cs_to_cy:    ;non-PWM, Port0.7 ;SPI.CS
 mov  dptr,IO_PIN_P06_P07_pwm   ;\
 movx a,[dptr]                  ;
 and  a,not 70h                 ;
 movx [dptr],a                  ;/
 and  [SFR_IO_PORT0_MODE_A],7Fh ;\
 or   [SFR_IO_PORT0_MODE_B],80h ;/
 mov  [SFR_IO_PORT0_DATA].7,c   ;-
 ret
;------------------
firm_set_p06_spi_res_to_cy:   ;non-PWM, Port0.6 ;SPI.RESET
 mov  dptr,IO_PIN_P06_P07_pwm   ;\
 movx a,[dptr]                  ;
 and  a,not 07h                 ;
 movx [dptr],a                  ;/
 and  [SFR_IO_PORT0_MODE_A],0BFh;\
 or   [SFR_IO_PORT0_MODE_B],40h ;/
 mov  [SFR_IO_PORT0_DATA].6,c   ;-
 ret
;------------------
firm_set_p37_spi_clk_to_cy:   ;non-PWM, Port3.7 ;SPI.CLK
 mov  dptr,IO_PIN_P37_xxx_pwm   ;\
 movx a,[dptr]                  ;
 and  a,not 07h                 ;
 movx [dptr],a                  ;/
 and  [SFR_IO_PORT3_MODE_A],7Fh ;\
 or   [SFR_IO_PORT3_MODE_B],80h ;/
 mov  [SFR_IO_PORT3_DATA].7,c   ;-
 ret
;------------------
firm_set_p36_volume_off:
 clr  c
;- - - - - - ------
firm_set_p36_spi_dta_to_cy:   ;non-PWM, Port3.6 ;SPI.DTA
 mov  dptr,IO_PIN_P35_P36_pwm   ;\
 movx a,[dptr]                  ;
 and  a,not 70h                 ;
 movx [dptr],a                  ;/
 and  [SFR_IO_PORT3_MODE_A],0BFh;\
 or   [SFR_IO_PORT3_MODE_B],40h ;/
 mov  [SFR_IO_PORT3_DATA].6,c   ;-
 ret
;------------------
;firm_set_p35_backlight_on:
;(this would set MAX brightness, instead: apply PWM)
; set  c
; sjmp firm_set_p35_backlight_to_cy
;--- --- --- ------
firm_set_p35_backlight_off:
 clr  c
;- - - - - - ------
firm_set_p35_backlight_to_cy:  ;non-PWM, Port3.5 ;BACKLIGHT
 mov  dptr,IO_PIN_P35_P36_pwm   ;\
 movx a,[dptr]                  ;
 and  a,not 07h                 ;
 movx [dptr],a                  ;/
 and  [SFR_IO_PORT3_MODE_A],0DFh;\
 or   [SFR_IO_PORT3_MODE_B],20h ;/
 mov  [SFR_IO_PORT3_DATA].5,c   ;-
 ret
;------------------
fastfac equ 4  ;assuming 2 clks/djnz (instead 8 clks/fast_other_delay_r6r7)
;------------------
write_HX8238_index_r2_data_r1r0:   ;HX8238-D
 push r0(0)  ;--> data.lsb
 push r1(0)  ;--> data.msb
 push r2(0)  ;--> index
 mov  a,70h      ;cmd.send.index        ;\
 call lcd_spi_send_r0_bits_from_a       ;/
 clr  a          ;index.msb             ;\
 call lcd_spi_send_r0_bits_from_a       ;/
 pop  a      ;<-- index.lsb             ;\
 call lcd_spi_send_r0_bits_from_a       ;/
 call lcd_spi_release                   ;-release
;- - -
 mov  a,73h      ;cmd.send.data         ;\
 call lcd_spi_send_r0_bits_from_a       ;/
 pop  a      ;<-- data.msb.1st          ;\
 call lcd_spi_send_r0_bits_from_a       ;/
 pop  a      ;<-- data.lsb.2nd          ;\
 call lcd_spi_send_r0_bits_from_a       ;/
 jmp  lcd_spi_release                   ;-release
 ret
;------------------
write_NV3035C_index_r0_data_a:  ;in: r0=index, a=data
 push a         ;---> data
 mov  a,r0      ;-index                 ;\
 set  c         ;\direction (1=write)   ;
 rcl  a         ;/                      ;
 set  c         ;\dummy (1)             ; index+RW+dummy
 rcl  a         ;/                      ;
 call lcd_spi_send_8_bits_from_a        ;/
 pop  a         ;<--- data              ;\data
 call lcd_spi_send_8_bits_from_a        ;/
 jmp  lcd_spi_release                   ;-release
;------------------
read_NV3035C_register_r0:   ;in: r0=index, out: a=data
 mov  a,r0      ;-index                 ;\
 clr  c         ;\direction (0=read)    ;
 rcl  a         ;/                      ; index+RW
 rcl  a         ;-move 7bits to MSBs    ;
 mov  r0,7                              ;
 call lcd_spi_send_r0_bits_from_a       ;/
 mov  r0,9                              ;\dummy+data
 call lcd_spi_recv_r0_bits_to_a         ;/
 jmp  lcd_spi_release                   ;-release
;------------------
lcd_spi_send_8_bits_from_a:    ;in: a=data
 mov  r0,8
;- - - - - - ------
lcd_spi_send_r0_bits_from_a:   ;in: a=data, r0=numbits (max 9 for data = A:CY)
   push a
   push dpl
   push dph
   mov  dptr,IO_PIN_P35_P36_pwm   ;\
   movx a,[dptr]                  ; set non-PWM mode (ie. no volume)
   and  a,not 70h                 ;
   movx [dptr],a                  ;/
   pop  dph
   pop  dpl
   pop  a

 and  [SFR_IO_PORT3_MODE_A],0BFh        ;\set dir DATA = OUTPUT
 or   [SFR_IO_PORT3_MODE_B],40h         ;/
 clr  [SFR_IO_PORT0_DATA].7             ;-set /CS=LOW
@@lop:
 rcl  a                                 ;\set DAT=data
 mov  [SFR_IO_PORT3_DATA].6,c           ;/
 clr  [SFR_IO_PORT3_DATA].7             ;\set CLK=LOW
 mov  r1,5*fastfac                      ; and delay 5
 djnz r1,$                              ;/
 set  [SFR_IO_PORT3_DATA].7             ;\set CLK=HIGH
 mov  r1,5*fastfac                      ; and delay 5
 djnz r1,$                              ;/
 djnz r0,@@lop                          ;-lop next
 ret
;------------------
lcd_spi_recv_r0_bits_to_a:  ;in: r0=numbits, out: a=databyte
 or   [SFR_IO_PORT3_MODE_A],40h         ;\set DIR = INPUT
 and  [SFR_IO_PORT3_MODE_B],not 40h     ;/
@@lop:
 clr  [SFR_IO_PORT3_DATA].7             ;\set CLK=LOW
 mov  r1,5*fastfac                      ; and delay 5
 djnz r1,$                              ;/
 mov  c,[SFR_IO_PORT3_DATA].6           ;\get data=DAT
 rcl  a                                 ;/
 set  [SFR_IO_PORT3_DATA].7             ;\set CLK=HIGH
 mov  r1,5*fastfac                      ; and delay 5
 djnz r1,$                              ;/
 djnz r0,@@lop                          ;-lop next
 ret
;------------------
lcd_spi_release:
 set  [SFR_IO_PORT0_DATA].7             ;\set /CS=HIGH
 mov  r0,20*fastfac                     ; and delay 20
 djnz r0,$                              ;/
 push a                                 ;\
 push dpl                               ;
 push dph                               ;
 mov  dptr,IO_PIN_P35_P36_pwm           ;
 movx a,[dptr]                          ; resume PWM1 (eg. volume)
 or   a,30h                             ;
 movx [dptr],a                          ;
 pop  dph                               ;
 pop  dpl                               ;
 pop  a                                 ;/
 ret
;------------------
;:----------------- IR code (infrared handler)
;------------------
firm_irq_0003h_ext_int0_infrared:  ;(vector 0003h)
.if with_infrared=0
   ret          ;dummy/reti
.else ;- - - - - - - InfraRed...
  ;note: this is weirdly reading the "command" and "device"
  ; at IRQ level, whilst reading the "flags" elsewhere.
  ;note: xram_sett_ir can be set to OFF,A,B - but it's left
  ; unused (it's usually "OFF" but IR is handled anyways, and
  ; the meaning of settings A,B is unknown; maybe it was
  ; intended for NEC vs RC-5, for different sets of NEC tables,
  ; or different wiring on mainboard/infrared unit).
  ;- - -
  ;push a
  ;push b
  ;push dph
  ;push dpl
  ;push psw
   mov  psw,00h
   push r0(0)
   push r1(0)
   push r2(0)
   push r3(0)
   push r4(0)
   push r5(0)
   push r6(0)
   push r7(0)
   call @@int0_core
   pop  r7(0)
   pop  r6(0)
   pop  r5(0)
   pop  r4(0)
   pop  r3(0)
   pop  r2(0)
   pop  r1(0)
   pop  r0(0)
  ;pop  psw
  ;pop  dpl
  ;pop  dph
  ;pop  b
  ;pop  a
   ret
  ;--- --- --- ------
  @@int0_core:
   ;--> http://www.remotecentral.com/cgi-bin/mboard/rc-discrete/thread.cgi?7182
   ;--> https://www.sbprojects.net/knowledge/ir/nec.php
   mov  dptr,IO_IR_stat_FF85h_used      ;\
   movx a,[dptr]                        ; get DEVICE msb
   mov  r1,a                            ;/
   mov  dptr,IO_IR_stat_FF83h_used      ;\
   movx a,[dptr]                        ; get DEVICE lsb
   mov  r0,a                            ;/
   jne  r0,86h,@@not_6B86h  ;lsb        ;\
   jne  r1,6Bh,@@not_6B86h  ;msb        ; accept 6B86h (134.107)
   sjmp @@accept                        ;
  @@not_6B86h:                          ;/
   jne  r0,000h,@@refuse    ;lsb        ;\accept FF00h (0.255)
   jne  r1,0FFh,@@refuse    ;msb        ;/
  @@accept:
   mov  a,[SFR_IO_IR_data]              ;-get COMMAND
   mov  [iram_ir_msb_device],r1         ;-apply msb (6Bh or FFh) aka device.msb
   mov  [iram_ir_lsb_cmd],a             ;-apply COMMAND (instead of device.lsb)
   mov  [SFR_IO_IR_data],0FFh           ;-ack command...?
   sjmp @@finish
  ;---
  @@refuse:
   mov  [SFR_IO_IR_data],0FFh           ;-ack command...?
   mov  a,0FFh
   mov  [iram_ir_msb_device],a
   mov  [iram_ir_lsb_cmd],a
  @@finish:
   ret
  ;------------------
  xlat_ir_code_to_keycode:  ;in: r6r7 - out: r7
   mov  dptr,infrared_code_list
  @@search_lop:
   mov  a,01h                                   ;\
   movc a,[a+dptr]                              ;
   jne  a,r6(0),@@search_lop_next               ; check if match
   mov  a,02h                                   ;
   movc a,[a+dptr]                              ;
   jne  a,r7(0),@@search_lop_next               ;/
   clr  a                                       ;\
   movc a,[a+dptr]                              ; found match
   sjmp @@this                                  ;/
  ;---
  @@search_lop_next:
   inc  dptr                                    ;\
   inc  dptr                                    ;
   inc  dptr                                    ; lop next
   clr  a                                       ;
   movc a,[a+dptr]                              ;
   jne  a,0ffh,@@search_lop                     ;/
   clr  a                                       ;-return 00h (not found)
  @@this:
   mov  r7,a            ;return keycode (or 00h=none)
   ret
  ;------------------
  check_IR_flags:   ;in: r6r7 - out: r6r7
   ;in: r6=[iram_ir_msb_device]
   ;in: r7=[iram_ir_lsb_cmd]
   ;- - -
   mov  a,[SFR_IO_IR_flags]             ;\   irq flag or so?
   jz   a.0,@@skip_ack                  ;/
   and  [SFR_IO_IR_flags],0FEh          ;-   ;<-- ack?
  @@skip_ack:
  ;- - -
   jne  r7,0FFh,@@not_FFh               ;\
   mov  a,r6                            ; check if FFFFh
   cpl  a                               ;
  @@not_FFh:                            ;
   jz   a,@@return_FFFFh ;--> is FFFFh  ;/
  ;- - -
   mov  a,0FFh                          ;\
   mov  [iram_ir_msb_device],a          ;
   mov  [iram_ir_lsb_cmd],a             ;/
   mov  b,[SFR_IO_IR_flags]             ;\
   mov  a,01h                           ;
   jz   b.1,@@this                      ;
   mov  a,02h                           ; maybe repeat flag?
  @@this:                               ;
   mov  dptr,xram_keypad_whatever       ;
   movx [dptr],a                        ;/
   ret             ;out: r6,r7
  ;- - -
  @@return_FFFFh:
   mov  r6,0ffh
   mov  r7,0ffh
   ret
  ;------------------
  check_infrared:
   mov  r7,[iram_ir_lsb_cmd]    ;\
   mov  r6,[iram_ir_msb_device] ;     ... IR flags
   call check_IR_flags          ;/
   jne  r7,0FFh,@@not_FFFFh     ;\
   jne  r6,0FFh,@@not_FFFFh     ; check if FFFFh
   clr  a                       ;
   sjmp @@none     ;out: a=0    ;/
  ;---
  @@not_FFFFh:
   mov  dptr,xram_keypad_was_read       ;\
   mov  a,02h                           ; set to 02h !!! (source of keystroke = infrared ?)
   movx [dptr],a                        ;/
   call xlat_ir_code_to_keycode   ;---> ;\
   mov  a,r7                            ;/
  @@none:      ;out: a
   mov  r7,a   ;out: r7
   ret
.endif
;------------------
;:----------------- IR code (infrared init)
;------------------
init_IR_hardware:   ;infrared
 and  [SFR_IO_PORT0_MODE_B],0F7h  ;clear bit3         ;-
 or   [SFR_IO_PORT0_MODE_A],08h   ;set bit3           ;-
 mov  dptr,firm_ir_init_io_list
 call init_io_via_io_list
 ret
;---
firm_ir_init_io_list:
 dw   IO_IR_config_FF82h // db 001h
 dw   IO_IR_config_FF62h // db 03Fh
 dw   IO_IR_config_FF63h // db 010h
 dw   IO_IR_config_FF64h // db 004h
 dw   IO_IR_config_FF6Bh // db 000h  ;<--NOT RW (but is written!?!)
 dw   IO_IR_config_FF6Ch // db 000h  ;<--NOT RW (but is written!?!)
 dw   IO_IR_config_FF6Dh // db 000h  ;<--NOT RW (but is written!?!)
 dw   IO_IR_config_FF6Eh // db 000h  ;<--NOT RW (but is written!?!)
 dw   IO_IR_config_FF79h // db 001h
 dw   IO_IR_config_FF7Ah // db 073h
 dw   IO_IR_config_FF7Bh // db 0FFh
 dw   IO_IR_config_FF7Ch // db 002h
 dw   IO_IR_config_FF77h // db 059h
 dw   IO_IR_config_FF78h // db 000h
 dw   IO_IR_config_FF65h // db 076h
 dw   IO_IR_config_FF66h // db 03Bh
 dw   IO_IR_config_FF67h // db 008h
 dw   IO_IR_config_FF68h // db 015h
 dw   IO_IR_config_FF69h // db 007h
 dw   IO_IR_config_FF6Ah // db 000h
 dw   IO_IR_config_FF6Fh // db 076h
 dw   IO_IR_config_FF70h // db 01Ch
 dw   IO_IR_config_FF71h // db 008h
 dw   IO_IR_config_FF72h // db 0F5h
 dw   IO_IR_config_FF61h // db 005h
 dw   IO_IR_config_FF7Dh // db 00Fh
 db   iolist_endcode
;------------------
infrared_code_list:    ;3-byte groups (8bit+16bit values)
 db   07h, 06Bh,04h    ;\      Plus
 db   08h, 06Bh,06h    ;       Minus
 db   0Eh, 06Bh,12h    ;       PowerOnOff
 db   09h, 06Bh,05h    ;       Next_menu
 db   0Ch, 06Bh,1Bh    ;       QuicklySourceMenu
 db   0Ah, 06Bh,1Ah    ;/      QuicklyMode
 db   07h, 0FFh,08h    ;\
 db   08h, 0FFh,0Ah    ;
 db   0Eh, 0FFh,02h    ;
 db   09h, 0FFh,09h    ;
 db   0Ch, 0FFh,05h    ;
 db   0Ah, 0FFh,0Dh    ;/
num_infrared_code_list_entries equ ($-infrared_code_list)/3
;------------------
;:----------------- ADC code (init analog hardware)
;------------------
init_ADC_analog_hardware:
 mov  dptr,firm_adc_init_io_list
 call init_io_via_io_list
 ret
;---
firm_adc_init_io_list:
 dw   IO_PLL_adc_clk_divider    // db 18h
 dw   IO_ADC_config_1           // db 20h
 dw   IO_ADC_ctrl_msb           // db 0Fh
 dw   IO_ADC_ctrl_lsb           // db 00h
 dw   IO_ADC_config_2           // db 22h
 dw   IO_ADC_config_3           // db 37h
 dw   IO_ADC_config_6           // db 0FFh
 dw   IO_ADC_config_7           // db 0Fh
 dw   IO_ADC_config_8           // db 00h
 dw   IO_ADC_speed_lsb          // db 0FFh
 dw   IO_ADC_speed_msb          // db 0Fh
 dw   IO_ADC_status_lsb         // db 00h
 dw   IO_ADC_status_msb         // db 00h
 dw   IO_ADC_config_4           // db 0FFh
 dw   IO_ADC_config_5           // db 0FFh
.if with_keypad_irq
 dw   IO_ADC_ctrl_lsb        // db 00h+8   ;bit3=1=enable channel 0     ;\
 dw   IO_ADC_ctrl_msb        // db 0Fh+20h ;bit5=1=whatever channel 0   ; launch
 dw   IO_ADC_config_4        // db 0FFh-4  ;bit2=0=irq enable channel 0 ;/
.endif
 db   iolist_endcode
;------------------
;:----------------- code (LCD SPI)
;------------------
display_spi_reset:    ;display RESET
 set  c                                         ;\non-PWM, Port0.7 ;SPI.CS
 call firm_set_p07_spi_cs_to_cy                 ;/
 set  c                                         ;\non-PWM, Port0.6 ;SPI.RESET
 call firm_set_p06_spi_res_to_cy                ;/
 set  c                                         ;\non-PWM, Port3.7 ;SPI.CLK
 call firm_set_p37_spi_clk_to_cy                ;/
 set  c                                         ;\non-PWM, Port3.6 ;SPI.DTA
 call firm_set_p36_spi_dta_to_cy                ;/
;- - -
 ;note: original firmware contained three insane 200ms delays here (600ms total)
 ;1st delay (before reset) shouldn't exist, ie. 0us (not 200000us)
 ;2nd delay (during reset) needs to be only 40us (not 200000us)
 ;3rd delay (after reset) needs to be only 10us (not 200000us)
 clr  c                                         ;\SPI.RESET=LOW (reset)
 call firm_set_p06_spi_res_to_cy                ;/
 mov  a,1                                       ;\delay 1ms (should be min 40us) (for NV3035C, or min 10us for HX8238-D)
 call firm_wait_a_milliseconds                  ;/
 set  c                                         ;\SPI.RESET=HIGH (release)
 call firm_set_p06_spi_res_to_cy                ;/
 mov  a,1                                       ;\delay 1ms (should be min 10us) (for NV3035C and HX8238-D) (before accessing SPI bus)
 jmp  firm_wait_a_milliseconds                  ;/
;------------------
display_spi_detect:
 mov  r0,02h                    ;\      ;\
 call read_NV3035C_register_r0  ;       ;
 jne  a,13h,@@not_NV3035C       ;/      ;
 mov  r0,04h                    ;\      ; detect NV3035C
 call read_NV3035C_register_r0  ;       ;
 jne  a,46h,@@not_NV3035C       ;/      ;
 mov  a,lcdspi_NV3035C                  ;
 sjmp @@this                            ;
@@not_NV3035C:                          ;/
 mov  a,lcdspi_UNKNOWN                  ;-else unknown
@@this:
 mov  dptr,xram_lcdspi_type             ;\apply type
 movx [dptr],a                          ;/
 ret
;------------------
display_spi_dump_initial:
 mov  dptr,xram_initial_spi_regs        ;\
 mov  r0,00h  ;index                    ;
@@lop:                                  ;
 push r0(0)                             ;
 call read_NV3035C_register_r0          ;
 pop  r0(0)                             ;
 movx [dptr],a                          ;
 inc  dptr                              ;
 inc  r0                                ;
 jne  r0,40h,@@lop                      ;/
 ret
;------------------
display_spi_init:
       ;... below is for a "HX8238-D" chip (as used in HX8238-D displays, which the firmware version strings claims to be used)
       ;... NOT matching for NV3035C ??!!! (as used in Tianma TM035KDH03, which I do actually have in my display)
       ;... (unless the NV3035C is in its undocumented "alternate" 3-wire SPI mode via its SPSW pin?)

 mov  dptr,hx8238_out_list
@@lop:
 clr  a                 ;\
 movc a,[a+dptr]        ; index
 inc  dptr              ;
 mov  r2,a              ;/
 clr  a                 ;\
 movc a,[a+dptr]        ; data.msb
 inc  dptr              ;
 mov  r1,a              ;/
 clr  a                 ;\
 movc a,[a+dptr]        ; data.lsb
 inc  dptr              ;
 mov  r0,a              ;/
 call write_HX8238_index_r2_data_r1r0   ;--> send
 clr  a                 ;\
 movc a,[a+dptr]        ; lop next
 jne  a,0ffh,@@lop      ;/
 ret
;---
hx8238_out_list:  ;index, data.msb, data.lsb
 db   01h, 063h,000h  ;\ HX8238.R01 Driver output control
 db   02h, 002h,000h  ;  HX8238.R02 LCD driver AC control
 db   03h, 076h,064h  ;  HX8238.R03 Power control (1)
 db   04h, 004h,047h  ;  Data and color filter control
 db   05h, 0BCh,014h  ;  ...?
 db   06h, 0E8h,060h  ;/ ...Reserved?
;db   08h, N/A        ;- ...missing...LED Control
 db   0Ah, 040h,008h  ;\ Contrast/Brightness Control
 db   0Bh, 0D4h,000h  ;/ ...?
 db   0Dh, 012h,03Ah  ;\ Power control (2)
 db   0Eh, 02Ch,0C0h  ;  Power control (3)
 db   0Fh, 000h,000h  ;/ Gate scan starting position
 db   16h, 09Fh,080h  ;\ Horizontal Porch
 db   17h, 022h,012h  ;/ Vertical Porch
 db   1Eh, 000h,0DDh  ;- Power control (4)
 db   30h, 005h,007h  ;\ y control (1)
 db   31h, 000h,004h  ;  y control (2)
 db   32h, 007h,007h  ;  y control (3)
 db   33h, 000h,000h  ;  y control (4)
 db   34h, 000h,000h  ;  y control (5)
 db   35h, 003h,007h  ;  y control (6)
 db   36h, 007h,000h  ;  y control (7)
 db   37h, 000h,000h  ;/ y control (8)
 db   3Ah, 014h,00Bh  ;\ y control (9)
 db   3Bh, 014h,00Bh  ;/ y control (10)
 db   0FFh  ;end
;------------------
;:----------------- Init I/O
;------------------
huge_fixed_io_list:
 dw   IO_PLL_0Bh_used             // db 040h   ;-
 dw   IO_PLL_0Dh_cfg              // db 0F0h   ;-
 dw   IO_PLL_10h_cfg              // db 004h   ;-(also set to 04h, too, elsewhere)
 dw   IO_PLL_dotclk_divider_2     // db 003h   ;-
 dw   IO_PLL_dotclk_divider_3     // db 002h   ;-
 dw   IO_PLL_1Ah_cfg              // db 008h   ;<-- this first
 dw   IO_AV_config_FE83h          // db 0FEh   ;-
 dw   IO_AV_ctrl_sensitivity_1    // db 0B1h   ;-
 dw   IO_LCD_sharpness_or_so      // db 00Fh   ;-
 dw   IO_LCD_config_FFB7h         // db 090h   ;- (also set to 90h, too, elsewhere)
 dw   IO_VIDEO_control            // db 002h   ;-
 dw   IO_60HZ_control_lsb         // db 001h   ;\
 dw   IO_60HZ_control_mid         // db 000h   ;
 dw   IO_60HZ_control_msb         // db 000h   ;/
 dw   IO_50HZ_control_lsb         // db 001h   ;\
 dw   IO_50HZ_control_mid         // db 000h   ;
 dw   IO_50HZ_control_msb         // db 000h   ;/
 dw   IO_OSD_bitmap_transp_misc   // db 000h  ;---
 dw   IO_OSD_screen_position      // db 000h  ;---
 dw   IO_LCD_config_FF00h         // db 003h  ;-
;.if tech_version<ver11sep2017  ;OLD VERSION ONLY
;  dw   IO_LCD_whatever_FFCBh     // db 02Ah   ;<--- initialized in OLD version only (but set to 80h elsewhere in both old+new version)
;.else   ;NEW VERSION ONLY...
;  dw   IO_AV_config_FEC9h        // db 001h   ;-not needed (it's 01h on power-up anyways)
;  dw   IO_60HZ_internal_unused1  // db 000h   ;\not needed (it's 2x00h on power-up anyways)
;  dw   IO_60HZ_internal_unused2  // db 000h   ;/
;  dw   IO_60HZ_internal_unused3  // db 014h   ;\
;  dw   IO_60HZ_internal_unused4  // db 000h   ;
;  dw   IO_60HZ_internal_unused5  // db 000h   ; not needed (it's 14h,4x00h on power-up anyways)
;  dw   IO_60HZ_internal_unused6  // db 000h   ;
;  dw   IO_60HZ_internal_unused7  // db 000h   ;/
;  dw   IO_50HZ_internal_unused1  // db 000h   ;\not needed (it's 2x00h on power-up anyways)
;  dw   IO_50HZ_internal_unused2  // db 000h   ;/
;  dw   IO_50HZ_internal_unused3  // db 014h   ;\
;  dw   IO_50HZ_internal_unused4  // db 000h   ;
;  dw   IO_50HZ_internal_unused5  // db 000h   ; not needed (it's 14h,4x00h on power-up anyways)
;  dw   IO_50HZ_internal_unused6  // db 000h   ;
;  dw   IO_50HZ_internal_unused7  // db 000h   ;/
;  dw   IO_VIDEO_something_4      // db 045h   ;-not needed (set to 45h elsewhere anyways)
;  dw   IO_LCD_whatever_FFh_1     // db 0FFh   ;\
;  dw   IO_LCD_whatever_FFh_2     // db 0FFh   ; not needed (it's 3xFFh on power-up anyways)
;  dw   IO_LCD_whatever_FFh_3     // db 0FFh   ;/
;.endif                                                               ;
;- - -

   .comment
     .if lcd_rgb_variant=1  ;gamma ramp...
       @@r00h equ 000h // @@r01h equ 003h // @@r02h equ 006h // @@r03h equ 00Ah
       @@r04h equ 00Eh // @@r05h equ 014h // @@r06h equ 01Ah // @@r07h equ 021h
       @@r08h equ 029h // @@r09h equ 034h // @@r0Ah equ 040h // @@r0Bh equ 04Dh
       @@r0Ch equ 059h // @@r0Dh equ 066h // @@r0Eh equ 073h // @@r0Fh equ 081h
       @@r10h equ 08Eh // @@r11h equ 09Ch // @@r12h equ 0A7h // @@r13h equ 0B1h
       @@r14h equ 0BAh // @@r15h equ 0C2h // @@r16h equ 0CAh // @@r17h equ 0D0h
       @@r18h equ 0D7h // @@r19h equ 0DDh // @@r1Ah equ 0E2h // @@r1Bh equ 0E7h
       @@r1Ch equ 0ECh // @@r1Dh equ 0F1h // @@r1Eh equ 0F6h // @@r1Fh equ 0FAh
       @@yuv0h equ 01Ah // @@yuv1h equ 006h // @@yuv2h equ 0D4h // @@yuv3h equ 0D2h
       @@yuv4h equ 0F1h // @@yuv5h equ 00Eh // @@yuv6h equ 015h // @@yuv7h equ 0E4h
       @@yuv8h equ 0F6h // @@yuv9h equ 0F1h // @@yuvAh equ 01Bh // @@yuvBh equ 081h
     .else
       @@r00h equ 000h // @@r01h equ 003h // @@r02h equ 007h // @@r03h equ 00Bh
       @@r04h equ 010h // @@r05h equ 015h // @@r06h equ 01Bh // @@r07h equ 022h
       @@r08h equ 02Ah // @@r09h equ 034h // @@r0Ah equ 03Fh // @@r0Bh equ 04Bh
       @@r0Ch equ 058h // @@r0Dh equ 065h // @@r0Eh equ 072h // @@r0Fh equ 07Eh
       @@r10h equ 089h // @@r11h equ 096h // @@r12h equ 0A2h // @@r13h equ 0AEh
       @@r14h equ 0BAh // @@r15h equ 0C4h // @@r16h equ 0CDh // @@r17h equ 0D5h
       @@r18h equ 0DCh // @@r19h equ 0E2h // @@r1Ah equ 0E7h // @@r1Bh equ 0ECh
       @@r1Ch equ 0F0h // @@r1Dh equ 0F4h // @@r1Eh equ 0F8h // @@r1Fh equ 0FBh
       @@yuv0h equ 011h // @@yuv1h equ 000h // @@yuv2h equ 000h // @@yuv3h equ 0E9h
       @@yuv4h equ 0E1h // @@yuv5h equ 00Eh // @@yuv6h equ 009h // @@yuv7h equ 0EEh
       @@yuv8h equ 0F4h // @@yuv9h equ 0F1h // @@yuvAh equ 023h // @@yuvBh equ 081h
     .endif
     ;- - -
      dw   IO_LCD_config_FFF0h         // db @@yuv0h ;\
      dw   IO_LCD_config_FFF1h         // db @@yuv1h ;
      dw   IO_LCD_config_FFF2h         // db @@yuv2h ;
      dw   IO_LCD_config_FFF3h         // db @@yuv3h ;
      dw   IO_LCD_config_FFF4h         // db @@yuv4h ;
      dw   IO_LCD_config_FFF5h         // db @@yuv5h ;
      dw   IO_LCD_config_FFF6h         // db @@yuv6h ;
      dw   IO_LCD_config_FFF7h         // db @@yuv7h ;
      dw   IO_LCD_config_FFF8h         // db @@yuv8h ;
      dw   IO_LCD_config_FFF9h         // db @@yuv9h ;
      dw   IO_LCD_config_FFFAh         // db @@yuvAh ;
      dw   IO_LCD_config_FFFBh         // db @@yuvBh ;/
     ;- - -
     .macro @@def_ramp
      dw   @@base+00h   // db @@r01h  ;\
      dw   @@base+01h   // db @@r02h  ;
      dw   @@base+02h   // db @@r03h  ;
      dw   @@base+03h   // db @@r04h  ;
      dw   @@base+04h   // db @@r05h  ; gamma ramp
      dw   @@base+05h   // db @@r06h  ;
      dw   @@base+06h   // db @@r07h  ;
      dw   @@base+07h   // db @@r08h  ;
      dw   @@base+08h   // db @@r09h  ;
      dw   @@base+09h   // db @@r0Ah  ;
      dw   @@base+0Ah   // db @@r0Bh  ;
      dw   @@base+0Bh   // db @@r0Ch  ;
      dw   @@base+0Ch   // db @@r0Dh  ;
      dw   @@base+0Dh   // db @@r0Eh  ;
      dw   @@base+0Eh   // db @@r0Fh  ;
      dw   @@base+0Fh   // db @@r10h  ;
      dw   @@base+10h   // db @@r11h  ;
      dw   @@base+11h   // db @@r12h  ;
      dw   @@base+12h   // db @@r13h  ;
      dw   @@base+13h   // db @@r14h  ;
      dw   @@base+14h   // db @@r15h  ;
      dw   @@base+15h   // db @@r16h  ;
      dw   @@base+16h   // db @@r17h  ;
      dw   @@base+17h   // db @@r18h  ;
      dw   @@base+18h   // db @@r19h  ;
      dw   @@base+19h   // db @@r1Ah  ;
      dw   @@base+1Ah   // db @@r1Bh  ;
      dw   @@base+1Bh   // db @@r1Ch  ;
      dw   @@base+1Ch   // db @@r1Dh  ;
      dw   @@base+1Dh   // db @@r1Eh  ;
      dw   @@base+1Eh   // db @@r1Fh  ;/
     .undef @@base
     .endm
     ;- - -
      @@base equ IO_LCD_gamma_ramp_red+0   // @@def_ramp ;-ramp RED
      @@base equ IO_LCD_gamma_ramp_green+0 // @@def_ramp ;-ramp GREEN
      @@base equ IO_LCD_gamma_ramp_blue+0  // @@def_ramp ;-ramp BLUE
   .comment

 db   iolist_endcode
;------------------
.macro def_resolution_io_list
 dw   IO_PLL_dotclk_multiplier    // db @@p0Ah ;- ;old/new=2Bh/A8h
 dw   IO_PLL_dotclk_divider_1     // db @@p0Fh ;- ;old/new=03h/09h
 dw   IO_PLL_16h_cfg              // db @@p16h ;- ;old/new=03h/0Ah
 dw   IO_PLL_19h_used             // db @@p19h ;<-- then this? ;old/new=83h/C3h
 dw   IO_AV_ctrl_whatever_2       // db @@what ;- ;old/new=00h/40h
 dw   IO_LCD_snow_enable_and_misc // db @@misc ;\ ;old/new=22h/23h
 dw   IO_LCD_config_FFB2h         // db @@trip ;  ;old/new=20h/10h
 dw   IO_LCD_config_FFB3h         // db @@trip ;  ;old/new=20h/10h
 dw   IO_LCD_config_FFB4h         // db @@trip ;/ ;old/new=20h/10h
;- - -
 dw   IO_VIDEO_something_1_lsb    // db @@ye and 0ffh   ;016h/03Ah   ;\
 dw   IO_VIDEO_something_1_msb    // db @@ye/100h       ;001h/001h   ;/
 dw   IO_VIDEO_something_2_lsb    // db @@yf and 0ffh   ;01Ch/03Ch   ;\ ;<--
 dw   IO_VIDEO_something_2_msb    // db @@yf/100h       ;001h/001h   ;/
 dw   IO_60HZ_15khz_lsb           // db @@yy60 and 0ffh ;0C8h/058h   ;\
 dw   IO_60HZ_15khz_msb           // db @@yy60/100h     ;003h/003h   ;
 dw   IO_60HZ_15khz_div2_lsb      // db @@xx60 and 0ffh ;0E3h/02Dh   ;
 dw   IO_60HZ_15khz_div2_msb      // db @@xx60/100h     ;001h/002h   ;
 dw   IO_60HZ_xloc_av_osd_lsb     // db @@xa60 and 0ffh ;000h/001h   ;
 dw   IO_60HZ_xloc_av_osd_msb     // db @@xa60/100h     ;000h/000h   ;
 dw   IO_60HZ_xloc_osd_lsb        // db @@xb60 and 0ffh ;044h/006h   ;
 dw   IO_60HZ_xloc_osd_msb        // db @@xb60/100h     ;000h/000h   ;
 dw   IO_60HZ_xloc_av_lsb         // db @@xc60 and 0ffh ;043h/027h   ;
 dw   IO_60HZ_xloc_av_msb         // db @@xc60/100h     ;000h/000h   ;
 dw   IO_60HZ_xcrop_end_av_lsb    // db @@xd60 and 0ffh ;08Ah/007h   ;
 dw   IO_60HZ_xcrop_end_av_msb    // db @@xd60/100h     ;001h/002h   ;
 dw   IO_60HZ_yloc_av_osd_lsb     // db @@ya60 and 0ffh ;007h/000h   ;
 dw   IO_60HZ_yloc_av_osd_msb     // db @@ya60/100h     ;000h/000h   ;
 dw   IO_60HZ_yloc_osd_lsb        // db @@yb60 and 0ffh ;009h/00Ah   ;
 dw   IO_60HZ_yloc_osd_msb        // db @@yb60/100h     ;000h/000h   ;
 dw   IO_60HZ_ycrop_upper_av_lsb  // db @@yc60 and 0ffh ;010h/018h   ;
 dw   IO_60HZ_ycrop_upper_av_msb  // db @@yc60/100h     ;000h/000h   ;
 dw   IO_60HZ_heavy_flimmer_lsb   // db @@yd60 and 0ffh ;010h/031h   ;
 dw   IO_60HZ_heavy_flimmer_msb   // db @@yd60/100h     ;001h/001h   ;/
 dw   IO_50HZ_15khz_lsb           // db @@yy50 and 0ffh ;066h/0F6h   ;\
 dw   IO_50HZ_15khz_msb           // db @@yy50/100h     ;004h/003h   ;
 dw   IO_50HZ_15khz_div2_lsb      // db @@xx50 and 0ffh ;036h/098h   ;
 dw   IO_50HZ_15khz_div2_msb      // db @@xx50/100h     ;002h/002h   ;
 dw   IO_50HZ_xloc_av_osd_lsb     // db @@xa50 and 0ffh ;002h/001h   ;
 dw   IO_50HZ_xloc_av_osd_msb     // db @@xa50/100h     ;000h/000h   ;
 dw   IO_50HZ_xloc_osd_lsb        // db @@xb50 and 0ffh ;036h/006h   ;
 dw   IO_50HZ_xloc_osd_msb        // db @@xb50/100h     ;000h/000h   ;
 dw   IO_50HZ_xloc_av_lsb         // db @@xc50 and 0ffh ;043h/027h   ;
 dw   IO_50HZ_xloc_av_msb         // db @@xc50/100h     ;000h/000h   ;
 dw   IO_50HZ_xcrop_end_av_lsb    // db @@xd50 and 0ffh ;092h/007h   ;
 dw   IO_50HZ_xcrop_end_av_msb    // db @@xd50/100h     ;001h/002h   ;
 dw   IO_50HZ_yloc_av_osd_lsb     // db @@ya50 and 0ffh ;008h/004h   ;
 dw   IO_50HZ_yloc_av_osd_msb     // db @@ya50/100h     ;000h/000h   ;
 dw   IO_50HZ_yloc_osd_lsb        // db @@yb50 and 0ffh ;009h/00Ah   ;
 dw   IO_50HZ_yloc_osd_msb        // db @@yb50/100h     ;000h/000h   ;
 dw   IO_50HZ_ycrop_upper_av_lsb  // db @@yc50 and 0ffh ;00Ch/018h   ;
 dw   IO_50HZ_ycrop_upper_av_msb  // db @@yc50/100h     ;000h/000h   ;
 dw   IO_50HZ_heavy_flimmer_lsb   // db @@yd50 and 0ffh ;00Fh/031h   ;
 dw   IO_50HZ_heavy_flimmer_msb   // db @@yd50/100h     ;001h/001h   ;/
 dw   IO_50HZ_boldness_contrast   // db 002h   ;-
 dw   IO_60HZ_boldness_contrast   // db @@bold ;- ;old/new=02h/00h  ;set here/now (instead earlier above)
 db   iolist_endcode
 .undef @@p0Ah
 .undef @@p0Fh
 .undef @@p16h
 .undef @@p19h
 .undef @@what
 .undef @@misc
 .undef @@trip
 .undef @@bold
 .undef @@yy60
 .undef @@xx60
 .undef @@xa60
 .undef @@xb60
 .undef @@xc60
 .undef @@xd60
 .undef @@ya60
 .undef @@yb60
 .undef @@yc60
 .undef @@yd60
 .undef @@ye
 .undef @@yf
 .undef @@yy50
 .undef @@xx50
 .undef @@xa50
 .undef @@xb50
 .undef @@xc50
 .undef @@xd50
 .undef @@ya50
 .undef @@yb50
 .undef @@yc50
 .undef @@yd50
.endm
;---
  ;320x240: dotclk=27MHz/8/3/3/2*43  =  8.0625 MHz
  ;470x272: dotclk=27MHz/8/9/3/2*168 = 10.5000 MHz
;NTSC    525/60  15.734kHz       60Hz
;PAL     625/50  15.625kHz       50Hz
;---
resolution_io_list_for_320x240:
  @@p0Ah equ 02Bh      ;IO_PLL_dotclk_multiplier  ;\                    ;\note: this is one multiplier, and two dividers (or vice-versa)
  @@p0Fh equ 003h      ;IO_PLL_dotclk_divider_1   ; for 240 lines ?     ; (bottom line is that video still works when multiplying all three values by N, eg. 2Bh*5,03h*5,03h*5)
  @@p16h equ 003h      ;IO_PLL_16h_cfg            ;/                    ;/
  @@p19h equ 083h      ;IO_PLL_19h_used
  @@what equ 000h      ;IO_AV_ctrl_whatever_2
  @@misc equ 022h      ;IO_LCD_snow_enable_and_misc
  @@trip equ 020h      ;IO_LCD_config_FFB2h..FFB4h
  @@bold equ 002h      ;IO_60HZ_boldness_contrast
  @@yy60 equ 003C8h ;        ;968    ;IO_60HZ_15khz_lsb
  @@xx60 equ 001E3h ;A3h+320 ;483    ;IO_60HZ_15khz_div2_lsb    ;8.0625MHz/60/116h
  @@xa60 equ 00000h ;00h+0           ;IO_60HZ_xloc_av_osd_lsb
  @@xb60 equ 00044h ;44h+0           ;IO_60HZ_xloc_osd_lsb
  @@xc60 equ 00043h ;43h+0           ;IO_60HZ_xloc_av_lsb
  @@xd60 equ 0018Ah ;4Ah+320 ;394    ;IO_60HZ_xcrop_end_av_lsb
  @@ya60 equ 00007h ;07h+0           ;IO_60HZ_yloc_av_osd_lsb
  @@yb60 equ 00009h ;09h+0           ;IO_60HZ_yloc_osd_lsb
  @@yc60 equ 00010h ;10h+0           ;IO_60HZ_ycrop_upper_av_lsb
  @@yd60 equ 00110h ;20h+240 ;272    ;IO_60HZ_heavy_flimmer_lsb
  @@ye   equ 00116h ;26h+240 ;278    ;IO_VIDEO_something_1_lsb
  @@yf   equ 0011Ch ;2Ch+240 ;284    ;IO_VIDEO_something_2_lsb
  @@yy50 equ 00466h          ;1126   ;IO_50HZ_15khz_lsb
  @@xx50 equ 00236h ;F6h+320 ;566    ;IO_50HZ_15khz_div2_lsb    ;8.0625MHz/50/11Ch
  @@xa50 equ 00002h ;02h+0           ;IO_50HZ_xloc_av_osd_lsb
  @@xb50 equ 00036h ;36h+0           ;IO_50HZ_xloc_osd_lsb
  @@xc50 equ 00043h ;43h+0           ;IO_50HZ_xloc_av_lsb
  @@xd50 equ 00192h ;52h+320 ;402    ;IO_50HZ_xcrop_end_av_lsb
  @@ya50 equ 00008h ;08h+0           ;IO_50HZ_yloc_av_osd_lsb
  @@yb50 equ 00009h ;09h+0           ;IO_50HZ_yloc_osd_lsb
  @@yc50 equ 0000Ch ;0Ch+0           ;IO_50HZ_ycrop_upper_av_lsb
  @@yd50 equ 0010Fh ;1Fh+240 ;271    ;IO_50HZ_heavy_flimmer_lsb
 def_resolution_io_list
;---                                               ;num lines ntsc/pal 262/312
resolution_io_list_for_480x272:
  @@p0Ah equ 0A8h      ;IO_PLL_dotclk_multiplier
  @@p0Fh equ 009h      ;IO_PLL_dotclk_divider_1
  @@p16h equ 00Ah      ;IO_PLL_16h_cfg
  @@p19h equ 0C3h      ;IO_PLL_19h_used
  @@what equ 040h      ;IO_AV_ctrl_whatever_2
  @@misc equ 023h      ;IO_LCD_snow_enable_and_misc
  @@trip equ 010h      ;IO_LCD_config_FFB2h..FFB4h
  @@bold equ 000h      ;IO_60HZ_boldness_contrast
  @@yy60 equ 00358h ;        ;856    ;IO_60HZ_15khz_lsb
  @@xx60 equ 0022Dh ;4Dh+480 ;557    ;IO_60HZ_15khz_div2_lsb    ;10.5MHz/60/13Ah  ;dotclks/scanline
  @@xa60 equ 00001h ;01h+0           ;IO_60HZ_xloc_av_osd_lsb
  @@xb60 equ 00006h ;06h+0           ;IO_60HZ_xloc_osd_lsb
  @@xc60 equ 00027h ;27h+0           ;IO_60HZ_xloc_av_lsb
  @@xd60 equ 00207h ;27h+480 ;519    ;IO_60HZ_xcrop_end_av_lsb
  @@ya60 equ 00000h ;00h+0           ;IO_60HZ_yloc_av_osd_lsb
  @@yb60 equ 0000Ah ;0Ah+0           ;IO_60HZ_yloc_osd_lsb
  @@yc60 equ 00018h ;18h+0           ;IO_60HZ_ycrop_upper_av_lsb
  @@yd60 equ 00131h ;21h+272 ;305    ;IO_60HZ_heavy_flimmer_lsb
  @@ye   equ 0013Ah ;2Ah+272 ;314    ;IO_VIDEO_something_1_lsb
  @@yf   equ 0013Ch ;2Ch+272 ;316    ;IO_VIDEO_something_2_lsb
  @@yy50 equ 003F6h          ;1014   ;IO_50HZ_15khz_lsb
  @@xx50 equ 00298h ;B8h+480 ;664    ;IO_50HZ_15khz_div2_lsb    ;10.5MHz/50/13Ch  ;dotclks/scanline
  @@xa50 equ 00001h ;01h+0           ;IO_50HZ_xloc_av_osd_lsb
  @@xb50 equ 00006h ;06h+0           ;IO_50HZ_xloc_osd_lsb
  @@xc50 equ 00027h ;27h+0           ;IO_50HZ_xloc_av_lsb
  @@xd50 equ 00207h ;27h+480 ;519    ;IO_50HZ_xcrop_end_av_lsb
  @@ya50 equ 00004h ;04h+0  ;!!!     ;IO_50HZ_yloc_av_osd_lsb
  @@yb50 equ 0000Ah ;0Ah+0           ;IO_50HZ_yloc_osd_lsb
  @@yc50 equ 00018h ;18h+0           ;IO_50HZ_ycrop_upper_av_lsb
  @@yd50 equ 00131h ;21h+272 ;305    ;IO_50HZ_heavy_flimmer_lsb
 def_resolution_io_list
;------------------
.macro def_mode_ratio_io_list
 dw   IO_60HZ_ratio_whatever_A_lsb      // db @@scale60 and 0ffh  ;\
 dw   IO_60HZ_ratio_whatever_A_msb      // db @@scale60/100h      ;/
 dw   IO_60HZ_ratio_xloc_av_8bit        // db @@x60               ;\
 dw   IO_60HZ_ratio_whatever_B_lsb      // db @@what              ;
 dw   IO_60HZ_ratio_whatever_B_msb      // db @@what              ;
 dw   IO_60HZ_ratio_ycrop_upper_av_8bit // db 00h                 ;
 dw   IO_60HZ_ratio_ycrop_lower_av_8bit // db 00h                 ;/
 dw   IO_50HZ_ratio_whatever_A_lsb      // db @@scale50 and 0ffh  ;\
 dw   IO_50HZ_ratio_whatever_A_msb      // db @@scale50/100h      ;/
 dw   IO_50HZ_ratio_xloc_av_8bit        // db @@x50               ;\
 dw   IO_50HZ_ratio_whatever_B_lsb      // db @@what              ;
 dw   IO_50HZ_ratio_whatever_B_msb      // db @@what              ;
 dw   IO_50HZ_ratio_ycrop_upper_av_8bit // db 00h                 ;
 dw   IO_50HZ_ratio_ycrop_lower_av_8bit // db 00h                 ;/
 db   iolist_endcode
.endm
;--- --- ---
mode_ratio_io_list_320x240_wide:  ;(aka normal ratio for 4:3 display)
 @@scale60 equ 0861h
 @@scale50 equ 085Ch
 @@x60     equ 10h
 @@x50     equ 06h
 @@what    equ 00h
 def_mode_ratio_io_list
;--- --- ---
mode_ratio_io_list_320x240_narrow:  ;(blah/dummy, not used for 4:3 display)
 @@scale60 equ 087Eh
 @@scale50 equ 0884h
 @@x60     equ 10h
 @@x50     equ 06h
 @@what    equ 00h
 def_mode_ratio_io_list
;--- --- ---
mode_ratio_io_list_480x272_wide:
 @@scale60 equ 05AFh
 @@scale50 equ 05A7h
 @@x60     equ 16h
 @@x50     equ 0Bh
 @@what    equ 00h
 def_mode_ratio_io_list
;--- --- ---
mode_ratio_io_list_480x272_narrow:
 @@scale60 equ 0762h
 @@scale50 equ 0770h
 @@x60     equ 16h
 @@x50     equ 0Bh
 @@what    equ 3Ch    ;whatever
 def_mode_ratio_io_list
;------------------
;basic_calibration_io_list:
;                ;with EIGHT alternate values per port?
;;- - - port                 //    PAL -   -  NTSC -   -   -   -
;.if lcd_rgb_variant=1
; dw IO_LCD_basic_contrast   // db 7Eh,80h,80h,7Eh,80h,80h,80h,80h
; dw IO_LCD_basic_brightness // db 8Eh,80h,80h,8Eh,80h,80h,80h,80h
; dw IO_LCD_basic_tint       // db 00h,00h,00h,00h,00h,00h,00h,00h
; dw IO_LCD_basic_saturation // db 38h,55h,55h,38h,55h,55h,55h,55h
;.else
; dw IO_LCD_basic_contrast   // db 80h,80h,80h,80h,80h,80h,80h,80h
; dw IO_LCD_basic_brightness // db 80h,80h,80h,80h,80h,80h,80h,80h
; dw IO_LCD_basic_tint       // db 00h,00h,00h,00h,00h,00h,00h,00h
; dw IO_LCD_basic_saturation // db 30h,36h,36h,30h,36h,36h,36h,36h
;.endif
;basic_calibration_io_list_num_entries equ ($-basic_calibration_io_list)/10
;------------------
output_initial_data_from_extra_fixed_io_list:   ;used TWICE
 mov  dptr,extra_fixed_io_list
 jmp  init_io_via_io_list
;------------------
extra_fixed_io_list:     ;this list is issued TWICE
 ;original firmware did also init "lcd_pin_variant" here
 ;(but that's now done when loading/applying user settings)
 dw   IO_PIN_P10_P11_spi_flash     // db 11h      ;\
 dw   IO_PIN_P12_P13_spi_flash     // db 11h      ;/
 dw   IO_PIN_maybe1_01h            // db 01h ;<-- ;\
 dw   IO_PIN_maybe2_zero           // db 00h      ;
 dw   IO_PIN_maybe3_zero           // db 00h      ;
 dw   IO_PIN_maybe4_zero           // db 00h      ; 8 bytes, first is 01h
 dw   IO_PIN_maybe5_zero           // db 00h      ;          others are 00h
 dw   IO_PIN_maybe6_zero           // db 00h      ;
 dw   IO_PIN_maybe7_zero           // db 00h      ;
 dw   IO_PIN_maybe8_zero           // db 00h      ;/
 db   iolist_endcode
;------------------
;:----------------- code (apply settings)
;------------------
apply_settings_to_IO_ports:
 call apply_backlight                   ;-
 call apply_volume                      ;-
;- - - - - - ------
apply_settings_to_IO_ports_except_backlight:
 call apply_panel_type                  ;-
 call apply_backdrop                    ;-backdrop (blue/snow/black)
;call apply_vcom_dc                     ;-
 call apply_mode_ratio                  ;-
 call apply_xyflip                      ;-
 call apply_rgb_gamma_ramps             ;-
 call apply_yuv_constants               ;-
 call apply_pal_ntsc                    ;-
 call apply_allow_c64                   ;-
 call apply_tianma_r0f                  ;-
;- - - - -
 mov  dptr,xram_sett_brightness         ;\
 movx a,[dptr]                          ;
 add  a,80h-50                          ; brightness
 mov  dptr,IO_LCD_basic_brightness      ;
 movx [dptr],a                          ;/
 mov  dptr,xram_sett_contrast           ;\
 movx a,[dptr]                          ;
 add  a,80h-50                          ; contrast
 mov  dptr,IO_LCD_basic_contrast        ;
 movx [dptr],a                          ;/
 mov  dptr,xram_sett_saturation         ;\
 movx a,[dptr]                          ;
 add  a,36h-50                          ; saturation
 mov  dptr,IO_LCD_basic_saturation      ;
 movx [dptr],a                          ;/
 call apply_tint                        ;-tint (ntsc)
;- - - - -
;note: no need to handle [xram_sett_input] here (will be done in IRQ handler)
;- - - - -
 clr  a     ;<--fixed (instead sett)    ;\
 mov  r7,a  ;=00h                       ; AV video on
 call xlat_r7_to_forced_blank_color     ;/
;- - - - -
 ret
;------------------
apply_tint:
 mov  dptr,IO_AV_stat_framerate_flag    ;\
 movx a,[dptr]                          ;
 jnz  a.2,@@pal  ;bit2: 1=50Hz          ;/
 mov  dptr,xram_sett_pal_ntsc           ;\
 movx a,[dptr]   ;1=force PAL60         ;
 jnz  a,@@pal                           ;/
;- - -
 mov  dptr,xram_sett_tint               ;\
 movx a,[dptr]                          ;
 add  a,00h-50                          ; tint (ntsc)
 mov  r0,a           ;\                 ;
 clr  c              ; negate           ; this (should) affect NTSC only,
 clr  a              ;                  ; however, bit7 smashes PAL colors,
 sbc  a,r0           ;/                 ; (above "@@pal" check avoids that
 jz   a,@@tint_zero  ;\when nonzero:    ; hardware glitch)
 xor  a,80h          ; flip bit7        ;
@@tint_zero:         ;/                 ;
 mov  dptr,IO_LCD_basic_tint            ;
 movx [dptr],a                          ;/
 ret
;---
@@pal:
 mov  dptr,IO_LCD_basic_tint            ;\
 clr  a                                 ; always force tint=00h for PAL
 movx [dptr],a                          ;/
 ret
;------------------
apply_pal_ntsc:
 mov  dptr,xram_sett_pal_ntsc    ;XXX tweak_pal60
 movx a,[dptr]
 jnz  a,@@force_pal60
;- - -
;@@allow_ntsc:
 mov  dptr,IO_VIDEO_control     ;\
 movx a,[dptr]                  ; allow IO_50Hz_xxx timings
 and  a,not 01h                 ;
 movx [dptr],a                  ;/
 mov  dptr,IO_AV_ctrl_whatever_1;\
 movx a,[dptr]                  ; allow NTSC-color decoding
 and  a,not 01h                 ;
 movx [dptr],a                  ;/

 mov  dptr,xram_sett_panel_type                 ;\
 movx a,[dptr]                                  ;
 jnz  a,@@skip_undo_adjust
     mov  dptr,IO_60HZ_15khz_lsb    ;\restore 15kHz to matched to NTSC
     mov  a,03c8h and 0ffh          ;
     movx [dptr],a                  ;/(XXX other for 480x272)

    ;;  mov  dptr,IO_60HZ_15khz_lsb      // mov a,0c8h // movx [dptr],a
    ;;  mov  dptr,IO_60HZ_15khz_div2_lsb // mov a,0e3h // movx [dptr],a
@@skip_undo_adjust:

 ret
;---
@@force_pal60:

   ;this causes heavy picture roll... when "firm_timer_coarse_release" occurs!

 mov  dptr,IO_VIDEO_control     ;\force using IO_60HZ_xxx
 movx a,[dptr]                  ; (for vertical timings)
 or   a,01h                     ; (DESPITE of FORCED PAL colors via FE01h.bit0)
 movx [dptr],a                  ;/
 mov  dptr,IO_AV_ctrl_whatever_1;\
 movx a,[dptr]                  ; force PAL-color decoding
 or   a,01h                     ;
 movx [dptr],a                  ;/

 mov  dptr,xram_sett_panel_type                 ;\
 movx a,[dptr]                                  ;
 jnz  a,@@skip_adjust
    mov  dptr,IO_60HZ_15khz_lsb    ;\adjust 15kHz to match better for PAL
    mov  a,03c0h and 0ffh          ; (XXX probably isn't optimal value yet)
    movx [dptr],a                  ;/(XXX whatever else for 480x272)

    ; mov  dptr,IO_60HZ_15khz_lsb      // mov a,000h // movx [dptr],a
    ; mov  dptr,IO_60HZ_15khz_msb      // mov a,002h // movx [dptr],a
    ; mov  dptr,IO_60HZ_15khz_div2_lsb // mov a,000h // movx [dptr],a
    ; mov  dptr,IO_60HZ_15khz_div2_msb // mov a,001h // movx [dptr],a

    ; mov  dptr,IO_60HZ_15khz_lsb      // mov a,0c8h-4 // movx [dptr],a
    ; mov  dptr,IO_60HZ_15khz_div2_lsb // mov a,0e3h+4 // movx [dptr],a
@@skip_adjust:

 ret
;------------------
apply_allow_c64:
 mov  dptr,xram_sett_allow_c64
 movx a,[dptr]
 jz   a,@@this   ;a=00h=allow C64
 mov  a,20h      ;a=20h=reset/default
@@this:
 mov  dptr,IO_AV_secret_control
 movx [dptr],a
 ret
;------------------
apply_tianma_r0f:
 mov  dptr,xram_sett_tianma_r0f
 movx a,[dptr]
 mov  r1,024h  ;recommended   (VGH=15V,VGL=-7V) (saves 1mA)
 jz   a,@@this
 mov  r1,0a4h  ;reset/default (VGH=15V,VGL=-10V) (eats up extra 1mA)
@@this:
 mov  r0,0fh  ;index NV3035C.R0F                ;\
 mov  a,r1    ;data                             ;
 call write_NV3035C_index_r0_data_a             ;/
 ret
;------------------
apply_rgb_gamma_ramps:
 mov  dptr,xram_sett_rgb_ramps
 movx a,[dptr]
 jz   a,@@new_ramps
 dec  a
 jz   a,@@old_ramps
;- - -
 mov  dptr,IO_LCD_gamma_ramp_red   // call ramp_linear
 mov  dptr,IO_LCD_gamma_ramp_green // call ramp_linear
 mov  dptr,IO_LCD_gamma_ramp_blue  // call ramp_linear
 ret
;---
@@new_ramps:
 mov  dptr,IO_LCD_gamma_ramp_red   // call ramp_normal_new
 mov  dptr,IO_LCD_gamma_ramp_green // call ramp_normal_new
 mov  dptr,IO_LCD_gamma_ramp_blue  // call ramp_normal_new
 ret
;---
@@old_ramps:
 mov  dptr,IO_LCD_gamma_ramp_red   // call ramp_normal_old
 mov  dptr,IO_LCD_gamma_ramp_green // call ramp_normal_old
 mov  dptr,IO_LCD_gamma_ramp_blue  // call ramp_normal_old
 ret
;------------------
ramp_clear:
 clr  a
 mov  r2,1fh
@@lop:
 movx [dptr],a
 inc  dptr
 djnz r2,@@lop
 ret
;------------------
ramp_linear:
 clr  a
 mov  r2,1fh
@@lop:
 movx [dptr],a
 add  a,8       ;step +8
 inc  dptr
 djnz r2,@@lop
 ret
;------------------
ramp_negative:
 clr  a
 mov  r2,1fh
@@lop:
 add  a,-8      ;step -8
 movx [dptr],a
 inc  dptr
 djnz r2,@@lop
 ret
;------------------
ramp_normal_old:
 clr  a   ;index
@@lop:
 push a   ;index
 push dpl
 push dph
 mov  dptr,old_gamma_ramp
 movc a,[a+dptr]  ;[index]
 pop  dph
 pop  dpl
 movx [dptr],a
 inc  dptr
 pop  a   ;index
 inc  a   ;index
 jne  a,1fh,@@lop
 ret
;---
ramp_normal_new:
 clr  a   ;index
@@lop:
 push a   ;index
 push dpl
 push dph
 mov  dptr,new_gamma_ramp
 movc a,[a+dptr]  ;[index]
 pop  dph
 pop  dpl
 movx [dptr],a
 inc  dptr
 pop  a   ;index
 inc  a   ;index
 jne  a,1fh,@@lop
 ret
;------------------
old_gamma_ramp:
 ;starts with small step (+3) (eg. 03h,06h)
 ;middle has BIG steps (+0Eh) (eg. 73h,81h)
 ;ends with small step (+4) (eg. F6h,FAh)
 ;though final bigger gap to FFh or 100h
 ;- - -
 db      003h,006h,00Ah,00Eh,014h,01Ah,021h
 db 029h,034h,040h,04Dh,059h,066h,073h,081h
 db 08Eh,09Ch,0A7h,0B1h,0BAh,0C2h,0CAh,0D0h
 db 0D7h,0DDh,0E2h,0E7h,0ECh,0F1h,0F6h,0FAh
;---
new_gamma_ramp:
 db      003h,007h,00Bh,010h,015h,01Bh,022h
 db 02Ah,034h,03Fh,04Bh,058h,065h,072h,07Eh
 db 089h,096h,0A2h,0AEh,0BAh,0C4h,0CDh,0D5h
 db 0DCh,0E2h,0E7h,0ECh,0F0h,0F4h,0F8h,0FBh
;------------------
old_yuv_constants:
 db 01Ah,006h,0D4h,0D2h,0F1h,00Eh,015h,0E4h,0F6h,0F1h,01Bh,081h
;---
new_yuv_constants:
 db 011h,000h,000h,0E9h,0E1h,00Eh,009h,0EEh,0F4h,0F1h,023h,081h
;------------------
firm_swap_dptr_vs_r1r0:
 push a
 mov  a,dpl     ;\
 xchg a,r0      ;
 mov  dpl,a     ;/
 mov  a,dph     ;\
 xchg a,r1      ;
 mov  dph,a     ;/
 pop  a
 ret
;------------------
apply_yuv_constants:
 mov  dptr,xram_sett_yuv_consts
 movx a,[dptr]
 mov  dptr,new_yuv_constants      ;src
 jz   a,@@this
 mov  dptr,old_yuv_constants      ;src
@@this:
 call firm_swap_dptr_vs_r1r0
 mov  dptr,IO_LCD_config_FFF0h+0  ;dst
 mov  r2,0ch                      ;len
@@lop:
 call firm_swap_dptr_vs_r1r0
 clr  a                         ;\
 movc a,[a+dptr]                ; src
 inc  dptr                      ;/
 call firm_swap_dptr_vs_r1r0
 movx [dptr],a                  ;\dst
 inc  dptr                      ;/
 djnz r2,@@lop
 ret
;------------------
apply_backdrop:
 mov  dptr,xram_sett_no_signal          ;\
 movx a,[dptr]                          ; get config
 mov  b,a                               ;/
 mov  dptr,IO_LCD_snow_enable_and_misc  ;\
 movx a,[dptr]                          ;
 mov  c,b.1     ;snow                   ; snow on/off
 mov  a.7,c     ;snow (0=off, 1=on)     ;
 set  a.5       ;whatever (1)           ;
 movx [dptr],a                          ;/
 mov  dptr,IO_backdrop_snow_level       ;\
 mov  a,6Ch                             ; amount of snow pixels
 movx [dptr],a                          ;/
 mov  a,b       ;snow                   ;\
 ror  a                                 ; color...
 xor  a,b       ;snow                   ;
 jz   a.0,@@want_black                  ;/
 mov  dptr,IO_LCD_backdrop_color_Y      ;\
 mov  a,13h                             ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_LCD_backdrop_color_Cb   ; BLUE
 mov  a,0DDh                            ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_LCD_backdrop_color_Cr   ;
 mov  a,72h                             ;
 movx [dptr],a                          ;/
 ret
;---
@@want_black:
 mov  dptr,IO_LCD_backdrop_color_Y      ;\
 clr  a                                 ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_LCD_backdrop_color_Cb   ; BLACK
 mov  a,80h                             ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_LCD_backdrop_color_Cr   ;
 movx [dptr],a                          ;/
 ret
;------------------
div_dptr_by_r0:    ;dptr=dptr/r0
 mov  r1,16+1
 clr  a
 clr  c
@@lop:
 jc   @@sub
 jne  a,r0(0),$+3  ;cmp
 jc   @@cont
@@sub:
 sbc  a,r0
 clr  c
@@cont:
 cpl  c
 xchg a,dpl     ;\
 rcl  a         ;
 xchg a,dpl     ;/
 xchg a,dph     ;\
 rcl  a         ;
 xchg a,dph     ;/
 rcl  a         ;-
 djnz r1,@@lop
 ret
;------------------
apply_backlight:
 ;there are some things to be recursed here...
 ;short high duties are weak (or even completely ignore), for example:
 ;  high=2000, low=2000 looks nice
 ;  high=1000, low=1000 looks too dark (although it 50% duty, too)
 ;  high=500,  low=500  leaves backlight OFF (although it 50% duty, too)
 ;  to get the backlight ON, duty should be at least around high=600
 ;abother issue is the total PWM rate leaking noise to speakers (including
 ;to PC speakers, at least sharing VCC/GND with a PC), for example:
 ;  total=4000 does produce 6.75kHz noise
 ;  the noise is most audible at duty 60%..99% (eg. high=3000, low=1000)
 ;  there is (obviously) no nouse at duty 100%
 ;  total=1200 would produce rather inaudible 22.5kHz noise
 ;  but total=1200 won't work below 50% (because high<600 is ignored)
 ;alltogether, it's best to use two different duty calculations:
 ;  for small duties: use fixed HIGH time (and variable TOTAL time)
 ;  for high duties: use fixed TOTAL time (and variable HIGH time)
 ;- - -
 ;  total=4000, at 50% gives 68.6mA and NICE brightness
 ;  total=1200, at 85% gives 68.1mA and NICE brightness (about as above)
 ;  total=600,  at 99% gives 64.3mA and NICE brightness (maybe a bit darker)
 ;- - -
 mov  dptr,xram_sett_backlight          ;\
 movx a,[dptr]                          ;/
 jz   a,@@use_fixed_total               ;\
 jne  a,50,$+3  ;CMP                    ; use FIXED TOTAL when duty=0 or duty>49
 jnc  @@use_fixed_total                 ;/
;- - -                                  ;-use FIXED HIGH when duty=1..49
@@dutyhigh equ 2000
 mov  r0,a                              ;\
 mov  dptr,@@dutyhigh*(100/4)  ;div4    ;
 call div_dptr_by_r0                    ;
 mov  a,dpl                             ; total = @@dutyhigh*100/percent
 mov  b,dph                             ;
 .rept 2        ;\                      ; (the div4/mul4 is to stay in
   add  a,a     ;                       ; 16bit maths range)
   xchg a,b     ; mul4                  ;
   rcl  a       ; (undo above div4)     ;
   xchg a,b     ;                       ;
   jc   @@max   ;                       ;
 .endm          ;                       ;
 sjmp @@ok      ;/                      ;
@@max:                                  ;
 mov a,0ffh     ;\max 16bit             ;
 mov b,0ffh     ;/                      ;
@@ok:                                   ;
 mov  dptr,IO_PWM0_duty_total_lsb       ;
 movx [dptr],a                          ;
 mov  dptr,IO_PWM0_duty_total_msb       ;
 mov  a,b                               ;
 movx [dptr],a                          ;/
 mov  dptr,IO_PWM0_duty_high_lsb        ;\
 mov  a,(@@dutyhigh and 0ffh)           ; duty = fixed
 movx [dptr],a                          ;
 mov  dptr,IO_PWM0_duty_high_msb        ;
 mov  a,(@@dutyhigh/100h)               ;
 movx [dptr],a                          ;/
 sjmp @@finish
;---
@@use_fixed_total:
@@total equ @@dutyhigh*2  ;<-- must be so for smooth transition between above/below methods
;@@total equ 4000  ;old                 ;27MHz/4000 = 6.75kHz
;@@total equ 400   ;too fast for 50%    ;27MHz/400  = 67.5kHz
;@@total equ 1000  ;too fast for 50%    ;27MHz/1000 = 27.0kHz
;@@total equ 1200                       ;27MHz/1200 = 22.5kHz
;@@total equ 1500                       ;27MHz/1500 = 18.0kHz
;@@total equ 2000                       ;27MHz/2000 = 13.5kHz
 mov  dptr,IO_PWM0_duty_total_lsb       ;\
 mov  a,(@@total and 0ffh)              ;
 movx [dptr],a                          ; total = fixed
 mov  dptr,IO_PWM0_duty_total_msb       ;
 mov  a,(@@total/100h)                  ;
 movx [dptr],a                          ;/
 mov  dptr,xram_sett_backlight          ;\
 movx a,[dptr]                          ;
 mov  b,@@total/100  ;div 100 decimal   ;
.errif (@@total mod 100)<>0             ;
 mul  a,b                               ;
 mov  dptr,IO_PWM0_duty_high_lsb        ; duty = total/100*percent
 movx [dptr],a                          ;
 mov  a,b                               ;
 mov  dptr,IO_PWM0_duty_high_msb        ;
 movx [dptr],a                          ;/
;- - -
@@finish:
 mov  dptr,IO_PIN_P35_P36_pwm           ;\BACKLIGHT
 movx a,[dptr]                          ; switch pin to PWM mode
 or   a,3                               ;
 movx [dptr],a                          ;/
 mov  dptr,IO_PWM_enable_flags          ;\
 movx a,[dptr]                          ; enable PWM #0
 or   a,1                               ;
 movx [dptr],a                          ;/
 .if 0
   ;experimental/testing stuff...
   ;copy to PWM0 to PWM1 (for scope view, when having a scope on PWM1)
   mov  dptr,IO_PWM0_duty_total_lsb       ;\
   movx a,[dptr]                          ;
   mov  dptr,IO_PWM1_duty_total_lsb       ;
   movx [dptr],a                          ;/
   mov  dptr,IO_PWM0_duty_total_msb       ;\
   movx a,[dptr]                          ;
   mov  dptr,IO_PWM1_duty_total_msb       ;
   movx [dptr],a                          ;/
   mov  dptr,IO_PWM0_duty_high_lsb        ;\
   movx a,[dptr]                          ;
   mov  dptr,IO_PWM1_duty_high_lsb        ;
   movx [dptr],a                          ;/
   mov  dptr,IO_PWM0_duty_high_msb        ;\
   movx a,[dptr]                          ;
   mov  dptr,IO_PWM1_duty_high_msb        ;
   movx [dptr],a                          ;/
   mov  dptr,IO_PIN_P35_P36_pwm           ;\PWM1
   movx a,[dptr]                          ; switch pin to PWM mode
   or   a,30h          +3                 ;
   movx [dptr],a                          ;/
   mov  dptr,IO_PWM_enable_flags          ;\
   movx a,[dptr]                          ; enable PWM #1
   or   a,2            +1                 ;
   movx [dptr],a                          ;/
 .endif
 ret
;------------------
apply_volume:
@@total equ 100    ;that gives 270kHz PWM
 mov  dptr,IO_PWM1_duty_total_lsb       ;\
 mov  a,(@@total and 0ffh)              ;
 movx [dptr],a                          ; total = fixed
 mov  dptr,IO_PWM1_duty_total_msb       ;
 mov  a,(@@total/100h)                  ;
 movx [dptr],a                          ;/
 mov  dptr,xram_sett_volume             ;\
 movx a,[dptr]                          ;
 mov  b,@@total/100  ;div 100 decimal   ;
.errif (@@total mod 100)<>0             ;
 mul  a,b                               ;
 mov  dptr,IO_PWM1_duty_high_lsb        ; duty = total/100*percent
 movx [dptr],a                          ;
 mov  a,b                               ;
 mov  dptr,IO_PWM1_duty_high_msb        ;
 movx [dptr],a                          ;/
 mov  dptr,IO_PIN_P35_P36_pwm           ;\PWM1
 movx a,[dptr]                          ; switch pin to PWM mode
 or   a,30h                             ;
 movx [dptr],a                          ;/
 mov  dptr,IO_PWM_enable_flags          ;\
 movx a,[dptr]                          ; enable PWM #1
 or   a,2                               ;
 movx [dptr],a                          ;/
 ret
;------------------
apply_xyflip:
 mov  dptr,xram_sett_xyflip                     ;\
 movx a,[dptr]                                  ;
 xor  a,03h  ;bit0=x, bit1=y (0=flip, 1=normal) ; flip at LCD display side
 mov  r0,02h ;index NV3035C.R02                 ;
 call write_NV3035C_index_r0_data_a             ;/
 mov  r2,01h            ;-index HX8238.R01      ;\
 mov  a,63h             ;\                      ;
 call get_xflip_flag    ;                       ;
 cpl  c                 ;                       ; flip at LCD display side
 mov  a.1,c  ;word.bit9 ; data.msb (flip)       ;
 call get_yflip_flag    ;                       ;
 cpl  c                 ;                       ;
 mov  a.6,c  ;word.bit14;                       ;
 mov  r1,a              ;/                      ;
 mov  r0,00h            ;-data.lsb              ;
 call write_HX8238_index_r2_data_r1r0           ;/
 mov  dptr,xram_sett_xyflip                     ;\
 movx a,[dptr]   ;000000yx                      ;
 mov  c,a.1      ;000000yx.y                    ; undo-flip at OSD side
 mov  a.2,c      ;00000yyx                      ; (also needs to 'flip' window
 mov  c,a.0      ;00000yyx.x                    ; xloc/yloc's by software)
 rcl  a          ;0000yyxx                      ;
 swap a          ;yyxx0000                      ;
 mov  dptr,IO_OSD_xyflip                        ;
 movx [dptr],a                                  ;/
 ret
;------------------
apply_panel_type:
 mov  dptr,xram_sett_panel_type                 ;\
 movx a,[dptr]                                  ;
 mov  dptr,lcd_pin_variant_io_list_tianma       ;
 jz   a,@@this_pins                             ; lcd_pin_variant
 mov  dptr,lcd_pin_variant_io_list_innolux      ;
@@this_pins:                                    ;
 call init_io_via_io_list                       ;/
 mov  dptr,xram_sett_panel_type                 ;\
 movx a,[dptr]                                  ;
 mov  dptr,resolution_io_list_for_320x240       ;
 jz   a,@@this_resolution                       ; resolution
 mov  dptr,resolution_io_list_for_480x272       ;
@@this_resolution:                              ;
 call init_io_via_io_list                       ;/
 ret
;---
lcd_pin_variant_io_list_tianma:
 dw   IO_PIN_P14_P15_lcd           // db 11h  ;\
 dw   IO_PIN_P16_P17_lcd           // db 11h  ;
 dw   IO_PIN_P20_P21_lcd           // db 11h  ;
 dw   IO_PIN_P22_GPIO0_lcd         // db 11h  ;
 dw   IO_PIN_GPIO1_GPIO2_lcd       // db 11h  ;
 dw   IO_PIN_GPIO3_GPIO4_lcd       // db 11h  ;
 dw   IO_PIN_P23_P24_lcd           // db 11h  ;
 dw   IO_PIN_P25_P26_lcd           // db 11h  ;
 dw   IO_PIN_GPIO5_GPIO6_lcd       // db 11h  ;
 dw   IO_PIN_GPIO7_GPIO8_lcd       // db 11h  ;
 dw   IO_PIN_GPIO9_GPIO10_lcd      // db 11h  ;
 dw   IO_PIN_P27_P30_lcd           // db 11h  ;
 dw   IO_PIN_P31_P32_lcd           // db 11h  ;
 dw   IO_PIN_P33_P34_lcd           // db 11h  ;/
 dw   IO_whatever_FD50h            // db 0Bh  ;-whatever (was previously set to 00h via init_part_4_subsubfunc)
 dw   IO_LCD_color_swap            // db 05h  ;-color swap Red/Blue
 db   iolist_endcode
;---
lcd_pin_variant_io_list_innolux:
 dw   IO_PIN_P14_P15_lcd           // db 22h  ;\
 dw   IO_PIN_P16_P17_lcd           // db 22h  ;
 dw   IO_PIN_P20_P21_lcd           // db 22h  ;
 dw   IO_PIN_P22_GPIO0_lcd         // db 22h  ;
 dw   IO_PIN_GPIO1_GPIO2_lcd       // db 22h  ;
 dw   IO_PIN_GPIO3_GPIO4_lcd       // db 22h  ;
 dw   IO_PIN_P23_P24_lcd           // db 22h  ;
 dw   IO_PIN_P25_P26_lcd           // db 22h  ;
 dw   IO_PIN_GPIO5_GPIO6_lcd       // db 22h  ;
 dw   IO_PIN_GPIO7_GPIO8_lcd       // db 22h  ;
 dw   IO_PIN_GPIO9_GPIO10_lcd      // db 22h  ;
 dw   IO_PIN_P27_P30_lcd           // db 22h  ;
 dw   IO_PIN_P31_P32_lcd           // db 22h  ;
 dw   IO_PIN_P33_P34_lcd           // db 22h  ;/
 dw   IO_whatever_FD50h            // db 0Fh  ;-whatever (was previously set to 00h via init_part_4_subsubfunc)
 dw   IO_LCD_color_swap            // db 00h  ;-color swap off
 db   iolist_endcode
;------------------
.if 0
apply_vcom_dc
;mov  dptr,xram_sett_vcom_dc_hi
 mov  dptr,xram_sett_vcom_dc_lo
 movx a,[dptr]
 mov  [iram_tmp__3Dh],a
 mov  r7,28h
 mov  r6,0Ah
 mov  r5,00h
 mov  r4,00h
 mov  xx,0..3
 call pwm_set_duty_pwm_xx
 mov  dptr,IO_PWM_enable_flags
 movx a,[dptr]
 or   a,01h shl xx
 movx [dptr],a
 ret
.endif
;------------------
;:----------------- SETTINGS
;------------------
init_load_settings:
 mov  dptr,xram_settings_start                  ;\
 mov  r3,xram_settings_size                     ;
 mov  r0,00h                                    ; read settings 1
 mov  r1,flash_settings_1_addr_div_100h and 0ffh;
 mov  r2,flash_settings_1_addr_div_100h/100h    ;
 call flash_read_r2r1r0_to_dptr_len_r3          ;/
 call verify_loaded_settings                    ;\check
 jc   @@okay                                    ;/
 mov  dptr,xram_settings_start                  ;\
 mov  r3,xram_settings_size                     ;
 mov  r0,00h                                    ; read settings 2
 mov  r1,flash_settings_2_addr_div_100h and 0ffh;
 mov  r2,flash_settings_2_addr_div_100h/100h    ;
 call flash_read_r2r1r0_to_dptr_len_r3          ;/
 call verify_loaded_settings                    ;\check
 jc   @@okay                                    ;/
;original firmware is doing 1-2 retries (is that needed in some cases?)
 call firm_reset_all_settings                   ;-oops, reset all
@@okay:
 ret
;------------------
force_valid_settings:
 ;settings range checks... (force default if invalid)
 ;(removed, the settings are verified on loading, so no need to do this here)
 ret
;------------------
firm_calc_settings_chksum:
 mov  dptr,xram_settings_start
 mov  r1,xram_settings_size-1
 mov  r0,00h  ;chksum
@@lop:
 movx a,[dptr]
 inc  dptr
 xor  a,r0
 mov  r0,a
 djnz r1,@@lop
 mov  a,r0
 ret
;------------------
firm_reset_all_settings:   ;(when flash load failure)
 mov  dptr,xram_settings_start  ;\
 mov  r1,xram_settings_size     ;
 clr  a                         ; zerofill
@@lop:                          ;
 movx [dptr],a                  ;
 inc  dptr                      ;
 djnz r1,@@lop                  ;/
 mov  a,32h  ;50 decimal        ;\
 mov  dptr,xram_sett_backlight  ;
 movx [dptr],a                  ;
 mov  dptr,xram_sett_brightness ;
 movx [dptr],a                  ;
 mov  dptr,xram_sett_saturation ; set bars to middle
 movx [dptr],a                  ;
 mov  dptr,xram_sett_contrast   ;
 movx [dptr],a                  ;
 mov  dptr,xram_sett_tint       ;
 movx [dptr],a                  ;
 mov  dptr,xram_sett_volume     ;
 movx [dptr],a                  ;/
 ret
;------------------
firm_do_save_settings:
 call force_valid_settings      ;-
 mov  dptr,xram_sett_id_5Ah     ;\
 mov  a,05Ah                    ; settings start marker
 movx [dptr],a                  ;/
 mov  dptr,xram_sett_id_A5h     ;\
 mov  a,0A5h                    ; settings end marker
 movx [dptr],a                  ;/
 call firm_calc_settings_chksum ;\
 mov  dptr,xram_sett_chksum     ; settings chksum
 movx [dptr],a                  ;/
;- - - -
@@wanted_wprot equ 24h  ;protect first 64Kbyte    ;XXX doesn't work, the damn MK 25D40 chip can't set TB flag in bit5
 call flash_read_write_protect_status_r0        ;\
 mov  a,r0                                      ;
 xor  a,@@wanted_wprot                          ;
 jz   a,@@already_protected_as_wanted           ;/
 call flash_write_enable                        ;-
 mov  r0,@@wanted_wprot                         ;\
 call flash_set_wprot_to_r0                     ;/
@@already_protected_as_wanted:
;- - - -
 mov  dptr,xram_settings_start                  ;\
 mov  r3,xram_settings_size                     ;
 mov  r0,00h                                    ;
 mov  r1,flash_settings_1_addr_div_100h and 0ffh;
 mov  r2,flash_settings_1_addr_div_100h/100h    ;
 call flash_write_dptr_to_r2r1r0_len_r3         ;/
 mov  a,32h                                     ;\delay 50 (unknown purpose)
 call firm_wait_a_milliseconds                  ;/
;- - - -
 mov  dptr,xram_settings_start                  ;\
 mov  r3,xram_settings_size                     ;
 mov  r0,00h                                    ;
 mov  r1,flash_settings_2_addr_div_100h and 0ffh;
 mov  r2,flash_settings_2_addr_div_100h/100h    ;
 call flash_write_dptr_to_r2r1r0_len_r3         ;/
 mov  a,32h                                     ;\delay 50 (unknown purpose)
 call firm_wait_a_milliseconds                  ;/
 ret
;------------------
;:----------------- init code
;------------------
init_io_via_huge_fixed_io_list:
 mov  dptr,huge_fixed_io_list                   ;\
 jmp  init_io_via_io_list                       ;/
;------------------
init_io_via_io_list:    ;in: dptr=list
@@lop:
 clr  a                         ;\
 movc a,[a+dptr]                ; get addr.msb
 inc  dptr                      ;
 mov  r1,a                      ;/
 xor  a,iolist_endcode          ;\
 jz   a,@@done                  ;/
 clr  a                         ;\
 movc a,[a+dptr]                ; get addr.lsb
 inc  dptr                      ;
 mov  r0,a                      ;/
 clr  a                         ;\
 movc a,[a+dptr]                ; get data
 inc  dptr                      ;/
 push dpl
 push dph
 mov  dpl,r0                    ;\
 mov  dph,r1                    ; output data
 movx [dptr],a                  ;/
 pop  dph
 pop  dpl
 jmp  @@lop
@@done:
 ret
;------------------
;:----------------- mode ratio / detected
;------------------
apply_mode_ratio:   ;Mode (16:9 or 4:3)
 mov  dptr,IO_VIDEO_something_4                 ;\maybe wants "pause" display?
 movx a,[dptr]                                  ; looks like BUGGED/blah
 or   a,40h                                     ; (it's 45h anyways)
 movx [dptr],a                                  ;/
;- - -
 mov  dptr,xram_sett_panel_type                 ;\
 movx a,[dptr]                                  ;
;mov  dptr,mode_ratio_io_list_320x240_narrow    ;
 mov  dptr,mode_ratio_io_list_320x240_wide      ;
 jz   a,@@this_ratio                            ; apply ratio (16:9 or 4:3)
 mov  dptr,xram_sett_ratio                      ; (depending on panel type)
 movx a,[dptr]                                  ;
 mov  dptr,mode_ratio_io_list_480x272_narrow    ;
 jz   a,@@this_ratio                            ;
 mov  dptr,mode_ratio_io_list_480x272_wide      ;
@@this_ratio:                                   ;
 call init_io_via_io_list                       ;/
;- - -
 mov  dptr,IO_VIDEO_something_5                 ;\maybe wants "resume" display?
 clr  a                                         ; looks like BUGGED/blah
 movx [dptr],a                                  ;/(seems to be unused/readonly)
 ret
;------------------
;:----------------- reset entrypoint
;------------------
reset_entrypoint:
 clr  ea        ;disable IRQs (for softreset/warmboot)
 mov  r0,7Fh                            ;\
 clr  a                                 ; zerofill [7Fh..01h]
@@zerofill_lop:                         ; (excluding r0 at [00h])
 mov  [r0],a                            ;
 djnz r0,@@zerofill_lop                 ;/
 mov  dptr,0000h                        ;\
 clr  a                                 ;
@@zerofill_xram_lop:                    ; zerofill xram [0000h..07FFh]
 movx [dptr],a                          ;
 inc  dptr                              ;
 mov  r0,dph                            ;
 jne  r0,08h,@@zerofill_xram_lop        ;/
 mov  sp,iram_firm_stack-1              ;-init stack
.if 0  ;removed for now (to avoid debug-warnings on unused SFR reads)
 mov  dptr,xram_initial_sfr_regs        ;\
 mov  r0,80h                            ;
@@dump_initial_sfr_lop:                 ;
 push dpl                               ;
 mov  dpl,r0                            ; for debug/diag
 call read_sfr_dpl                      ; (though some CPU regs aren't at
 pop  dpl                               ; their initial states:
 movx [dptr],a                          ; a,b,dpl,dph,sp,psw)
 inc  dptr                              ;
 inc  r0                                ;
 jne  r0,00h,@@dump_initial_sfr_lop     ;/
.endif
 mov  dptr,xram_initial_hw_regs         ;\
 call firm_swap_dptr_vs_r1r0            ;
 mov  dptr,0FB00h                       ;
@@dump_initial_regs_lop:                ;
 movx a,[dptr]                          ; for debug/diag
 inc  dptr                              ;
 call firm_swap_dptr_vs_r1r0            ;
 movx [dptr],a                          ;
 inc  dptr                              ;
 call firm_swap_dptr_vs_r1r0            ;
 mov  a,dph                             ;
 jnz  a,@@dump_initial_regs_lop         ;/
 call firm_set_p35_backlight_off        ;-backlight OFF
 call firm_set_p36_volume_off           ;-volume OFF
;- - - -
 mov  dptr,xram_irq_coarse_offhold        // mov a,00h  // movx [dptr],a
 mov  dptr,xram_old_AV_stat_signal_detect // mov a,0FFh // movx [dptr],a  ;initial value FFh=invalid (later set to 4bit value)
 mov  dptr,xram_irq_artifacts_offhold     // mov a,00h  // movx [dptr],a
 mov  dptr,xram_old_AV_stat_detect_2      // mov a,0FFh // movx [dptr],a
 mov  dptr,xram_irq_sharpness_offhold     // mov a,00h  // movx [dptr],a
 mov  dptr,xram_irq_sensitivity_offhold   // mov a,00h  // movx [dptr],a
;- - - -
 call main_init                                 ;-
;- - - -
 mov  a,sysgui_index_main_menu          ;\
 mov  [iram_sysgui_menu_index],a        ;/

 call watchdog_disable
 call sysgui_make_font

 mov  dptr,IO_OSD_bitmap_colors                                         ;\
 mov  a,077h // movx [dptr],a // inc dptr // movx [dptr],a // inc dptr  ;
 mov  a,044h // movx [dptr],a // inc dptr // movx [dptr],a // inc dptr  ; colors
 mov  a,0ffh // movx [dptr],a // inc dptr // movx [dptr],a // inc dptr  ;
 mov  a,077h // movx [dptr],a // inc dptr // movx [dptr],a // inc dptr  ;/

.if with_keypad_irq
   ;XXX wait until "num_keypad_readings" are available in xram
.endif
 call getkey                      ;\    ;\
 jnz  a.1,@@prompt_panel_type     ;/    ; force prompt panel type
 mov  dptr,xram_sett_id_5Ah       ;\    ; (on first boot, when settings didn't
 movx a,[dptr]                    ;     ; exist, or when MENU key held down)
 jne  a,5Ah,@@no_settings_loaded  ;/    ;
@@have_detected_panel_type:             ;/

  ;;;call switch_screen_and_backlight_on   ;<-- this needed for AV image!
  ;;;jmp  nocash_test_entrypoint

 jmp  sysgui_standby                    ;-boot normal
;---
@@no_settings_loaded:
 mov  dptr,xram_lcdspi_type
 movx a,[dptr]
 jne  a,lcdspi_NV3035C,@@prompt_panel_type
 clr  a                                 ;\when NV3035C --> assume tianma 320x240
 mov  dptr,xram_sett_panel_type         ; (this omits prompting for known LCDs,
 movx [dptr],a                          ; and also omits prompting in no$x51)
 sjmp @@have_detected_panel_type        ;/
;---
@@prompt_panel_type:
 call switch_screen_and_backlight_on
 call sysgui_prompt_panel_type
 call firm_do_save_settings
 jmp  sysgui_select_menu
;------------------
firm_mainloop_callback:
 call watchdog_reload                   ;--- watchdog maybe?

;- - - -
 ;;;sjmp @@mainloop
 ret
;------------------
;:----------------- .......................
;------------------
apply_av_input_a:
;- - -    IO_AV_video_on_off
;- - -    |             IO_AV_input_select_reg_0
;- - -    |             |             IO_AV_input_select_reg_1
;Input    FED7h.bit3-4  FED8h.bit6-7  FEDCh.bit4-5
;AV1      0-then-3      2             0   ;<-- CVBS1
;AV2      0-then-3      2             3   ;<-- still picks up something (stripes when CVBS3 has signal)
;AV3      0-then-3      0             2   ;<-- CVBS3
;Invalid  0-then-3      3             3   ;<-- still picks up something (stripes when CVBS3 has signal)
;- - - changes in NEWER FIRMWARE:
;AV1      0-then-3      0 !           2 ! ;<-- CVBS3 (other/swapped as in old firmware)
;AV2      0-then-3      0 !           3   ;<-- whatever weirdly different as in old firmware
;AV3      0-then-3      2 !           0 ! ;<-- CVBS1 (other/swapped as in old firmware)
;Invalid  0-then-3      3             3   ;<--
;- - -
 mov  r0,80h                    ;\
 mov  r1,00h                    ; CVBS1 (AV1) (aka AV2 in newer firmware)
 jz   a,@@this                  ;/
 dec  a
 mov  r0,80h ;<-- old firmware  ;\
 mov  r0,00h ;<-- new firmware  ; CVBS2 or so (unused)
 mov  r1,30h                    ;
 jz   a,@@this                  ;/
 dec  a
 mov  r0,00h                    ;\
 mov  r1,20h                    ; CVBS3 (AV2) (aka AV1 in newer firmware)
 jz   a,@@this                  ;/
 mov  r0,0C0h                   ;\INVALID or so (unused)
 mov  r1,30h                    ;/
@@this:
 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; temporarily clear bit3-4
 and  a,0E7h                            ;
 movx [dptr],a                          ;/
 inc  dptr ;=IO_AV_input_select_reg_0   ;\
 movx a,[dptr]                          ;
 and  a,not 0c0h                        ; select_reg_0
 or   a,r0                              ;
 movx [dptr],a                          ;/
 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; switch bit3-4 back on
 or   a,18h                             ;
 movx [dptr],a                          ;/
 mov  dptr,IO_AV_input_select_reg_1     ;\
 movx a,[dptr]                          ;
 and  a,not 30h                         ; select_reg_1
 or   a,r1                              ;
 movx [dptr],a                          ;/
 ret
;------------------
switch_screen_and_backlight_off:
 call firm_set_p35_backlight_off                ;-backlight OFF
 mov  a,64h                                     ;\delay 100
 call firm_wait_a_milliseconds                  ;/
 mov  r7,06h   ;<--fixed (instead sett)         ;\force black
 call xlat_r7_to_forced_blank_color             ;/
 call switch_lcd_screen_off                     ;-LCD off, BLACK
 call firm_set_p36_volume_off                   ;-volume OFF (after above SPI)
 ret
;------------------
switch_screen_and_backlight_on:
 call switch_lcd_screen_on                      ;-LCD ON
 clr  a     ;<--fixed (instead sett)            ;\
 mov  r7,a  ;=00h                               ; AV video on
 call xlat_r7_to_forced_blank_color             ;/
;- - -
 mov  dptr,IO_AV_stat_detect_0                  ;\
 movx a,[dptr]                                  ;
 and  a,06h                                     ;
 mov  r7,a                                      ;
 jne  r7,06h,@@skip_whatever                    ;
 mov  dptr,IO_AV_ctrl_whatever_2        ;\      ;
 movx a,[dptr]                          ;       ;
 or   a,40h                             ;       ;
 movx [dptr],a                          ;/      ;
 mov  dptr,IO_LCD_whatever_FFD8h        ;\      ;
 movx a,[dptr]                          ;       ;
 and  a,7Fh                             ;       ;
 movx [dptr],a                          ;/      ;
@@skip_whatever:                                ;/
;- - -
 mov  a,64h                                     ;\delay 100
 call firm_wait_a_milliseconds                  ;/
;call firm_set_p35_backlight_on                 ;-backlight on
 call apply_backlight                           ;-backlight on (pwm)
 call apply_volume                              ;-voume on (pwm)
 mov  a,14h                                     ;\delay 20
 call firm_wait_a_milliseconds                  ;/
;- - -
 mov  dptr,IO_AV_stat_detect_0                  ;\
 movx a,[dptr]                                  ;
 and  a,06h                                     ;
 mov  r7,a                                      ;
 jne  r7,06h,@@exit                             ;
 mov  dptr,IO_LCD_whatever_FFD8h        ;\      ;
 movx a,[dptr]                          ;       ;
 or   a,80h                             ;       ;
 movx [dptr],a                          ;/      ;
@@exit:                                         ;/
 ret
;------------------
switch_lcd_screen_on:
 mov  r0,00h  ;index NV3035C.R00                ;\
 mov  a,003h  ;data (wake)                      ;
 call write_NV3035C_index_r0_data_a             ;/
 mov  r2,03h               ;index HX8238.R03    ;\
 mov  r1,76h               ;data.msb            ;
 mov  r0,64h               ;data.lsb (wake)     ;
 call write_HX8238_index_r2_data_r1r0           ;/
 mov  dptr,IO_PLL_0Eh_used                      ;\
 mov  a,2Ch                                     ;
 movx [dptr],a                                  ;/
 mov  dptr,IO_AV_ctrl_sensitivity_1             ;\
 mov  a,0B1h  ;<-- needed (when leaving this at 00h, then "NoSignal" would act as "NTSC with gray-snow")
 movx [dptr],a                                  ;/
 mov  a,0FFh                            ;\
 mov  dptr,IO_PLL_11h_used              ;
 movx [dptr],a                          ;
 inc  dptr ;=IO_PLL_12h_used            ; PLL's
 movx [dptr],a                          ;
 inc  dptr ;=IO_PLL_13h_used            ;
 movx [dptr],a                          ;/
 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; AV
 or   a,03h                             ;
 movx [dptr],a                          ;/
;- - -
 mov  a,32h                             ;\delay 50
 call firm_wait_a_milliseconds          ;/
 mov  dptr,IO_AV_force_resync           ;\
 movx a,[dptr]                          ;
 or   a,01h                             ;
 movx [dptr],a                          ;/
 mov  a,0Ah                             ;\delay 10
 call firm_wait_a_milliseconds          ;/
 mov  dptr,IO_AV_force_resync           ;\
 movx a,[dptr]                          ;
 and  a,0FEh                            ;
 movx [dptr],a                          ;/
 mov  a,32h                             ;\delay 50
 call firm_wait_a_milliseconds          ;/
 ret
;------------------
switch_lcd_screen_off:
 mov  r0,00h  ;index NV3035C.R00                ;\drops to 18.1mA
 mov  a,001h  ;data (bit1:0=standby)            ; (formerly 31.2mA)
 call write_NV3035C_index_r0_data_a             ;/
 mov  r2,03h               ;index HX8238.R03    ;\
 mov  r1,76h               ;data.msb            ; similar to above
 mov  r0,64h and (not 0Eh) ;data.lsb (standby)  ; (for other display type)
 call write_HX8238_index_r2_data_r1r0           ;/
 mov  dptr,IO_PLL_0Eh_used                      ;\drops to 10.4mA
 mov  a,20h                                     ; (formerly 18.1mA)
 movx [dptr],a                                  ;/
 mov  dptr,IO_AV_ctrl_sensitivity_1             ;\drops to 8.3mA
 clr  a                                         ; (formerly 10.4mA)
 movx [dptr],a                                  ;/
 mov  dptr,IO_PLL_11h_used              ;\                    ;\
 mov  a,0Fh  ;keep CPU and AV/bit3      ; PLL                 ;
 movx [dptr],a                          ;/                    ;
 inc  dptr ;=IO_PLL_12h_used            ;\                    ; drops to 31.2mA
 mov  a,18h  ;keep ADC ... and AV       ; PLL                 ; (formerly
 movx [dptr],a                          ;/                    ; ca. 60mA)
 inc  dptr ;=IO_PLL_13h_used            ;\                    ;
 clr  a         ;set to 00h             ; PLL                 ;
 movx [dptr],a                          ;/                    ;
 mov  dptr,IO_AV_video_on_off           ;\                    ;
 movx a,[dptr]                          ; AV (disables snow   ;
 and  a,0FCh                            ; and AV input)       ;
 movx [dptr],a                          ;/                    ;/
 ret
;------------------
;:----------------- misc code
;------------------
xlat_r7_to_forced_blank_color:
 ;in: r7 = 00h or 06h or [xram_sett_blankcolor]
 ;- - -
 mov  a,r7
 jne  a,07h,$+3   ;aka CMP      ;\accept 0..6 only
 jnc  @@ignore_invalid          ;/
 mov  dptr,@@blank_color_list
 movc a,[a+dptr]
 mov  dptr,IO_LCD_forced_blank_color
 movx [dptr],a
@@ignore_invalid:
 ret
;---
@@blank_color_list:
 db 4Fh  ;0  ;ljmp @@xlat_0h_to_4Fh_av_video_on
 db 50h  ;1  ;ljmp @@xlat_1h_to_50h_force_screen_red
 db 51h  ;2  ;ljmp @@xlat_2h_to_51h_force_screen_green
 db 52h  ;3  ;ljmp @@xlat_3h_to_52h_force_screen_blue
 db 53h  ;4  ;ljmp @@xlat_4h_to_53h_force_screen_dgray
 db 55h  ;5  ;ljmp @@xlat_5h_to_55h_force_screen_lgray ;\xlat swapped here
 db 54h  ;6  ;ljmp @@xlat_6h_to_54h_force_screen_black ;/
;------------------
init_lcd_pins_and_force_display_off:
 call output_initial_data_from_extra_fixed_io_list      ;-PIN's
 mov  r7,06h  ;<--fixed (instead sett)  ;\force black
 call xlat_r7_to_forced_blank_color     ;/
 call firm_set_p35_backlight_off        ;-backlight OFF
 call firm_set_p36_volume_off           ;-volume OFF
 ret
;------------------
set_baudrate_57600bps:   ;init 80C52-style Timer2 for baudrate
 ;computes the baudrate reload value as so:
 ; -27000000/(57600*32) = -14.6484375 = rounded = -14 = FFF2h
 ;due to the rounding, this will produce:
 ; -27000000/-14/32 = 60267.85714 bauds = does that work well?
 ;alternately, a bit closer would be:
 ; -27000000/-15/32 = 56250 bauds
 ;best would be to avoid/reduce the div32 effect if possible
 ;(at least standard 80C51's allow to select div16 in PCON)
 ;- - -
@@rate57600 equ 0FFF2h
 ;- - -
 clr  [SFR_IO_baudrate_control].2                 ;-
 mov  [SFR_IO_baudrate_control],30h               ;-
 mov  [SFR_IO_sio_scon],50h                       ;-mode (uart, 8bit, no parity)
 mov  [SFR_IO_baudrate_msb],@@rate57600/100h      ;\baudrate
 mov  [SFR_IO_baudrate_lsb],@@rate57600 and 0ffh  ;/
 set  [SFR_IO_baudrate_control].2                 ;-
 set  es1         ;XXXsfr  ;iec.5  ;TMR2 irq enable?  (1=On) (uh, but IRQ vector 002Bh doesn't exist?!)
 clr  ti          ;XXXsfr  ;scon.1 ;UART Tx IRQ flag  (0=ack)
 clr  ri          ;XXXsfr  ;scon.0 ;UART Rx IRQ flag  (0=ack)
 clr  es0         ;XXXsfr  ;iec.4  ;UART irq enable   (0=Off)
 ret
;------------------
init_OSD_hardware:
 mov  dptr,init_osd_io_list                     ;\init I/O ports
 call init_io_via_io_list                       ;/
 mov  dptr,IO_OSD_bgmap_addr_lsb                ;\
 clr  a                                         ;
 movx [dptr],a                                  ;
 mov  r0,a     ;inner lopcount (=100h)          ;
 mov  r1,a     ;addr.msb (=0)                   ;
@@clr_bgmap_outer_lop:                          ; clear bgmap
 mov  dptr,IO_OSD_bgmap_addr_msb                ;
 mov  a,r1                                      ;
 movx [dptr],a                                  ;
 mov  dptr,IO_OSD_bgmap_data_msb        ;\      ;
 mov  a,01c0h/100h                      ;       ;
 movx [dptr],a                          ;       ;
 mov  dptr,IO_OSD_bgmap_data_lsb        ; data  ;
 mov  a,01c0h and 0ffh                  ;       ;
@@clr_bgmap_data_inner_lop:             ;       ;
 movx [dptr],a                          ;       ;
 djnz r0,@@clr_bgmap_data_inner_lop     ;/      ;
 mov  dptr,IO_OSD_bgmap_data_attr       ;\      ;
 mov  a,12h                             ;       ;
@@clr_bgmap_attr_inner_lop:             ; attr  ;
 movx [dptr],a                          ;       ;
 djnz r0,@@clr_bgmap_attr_inner_lop     ;/      ;
 inc  r1                                        ;
 jne  r1,2,@@clr_bgmap_outer_lop                ;/


 mov  dptr,IO_OSD_font_addr_lsb
 mov  dptr,IO_OSD_font_data_lsb
 mov  dptr,IO_OSD_font_data_msb
 mov  dptr,IO_OSD_font_addr_msb
;XXX init bitmap colors

 ret
;---
init_osd_io_list:
 dw   IO_OSD_window_enable_bits    // db 00h ;-bit0..4=enable window 0..4, bit5s=?, bit6:hides windows,TEXT ON/OFF, bit7:bitmap,BITMAP ON/OFF
 dw   IO_OSD_misc_transp_enable    // db 00h ;-upper2bit=semitrans.ctrl, other6bit=?
 dw   IO_OSD_bright_transp_level   // db 80h ;-upper3bit=brightness, lower3bit=transparency, middle2bit=?
 dw   IO_OSD_bitmap_start_lsb      // db 0   ;\
 dw   IO_OSD_bitmap_start_msb      // db 0   ;/
 dw   IO_OSD_bitmap_transp_misc    // db 00h ;-fixed (00h)  ;changes to bit3,5 affect window positions (bit3=SOMEpixX, bit5=1pixY) (bit4:bitmap TRANSP color0?)    ;bit6-7:NOT R/W
 dw   IO_OSD_screen_position       // db 00h ;-fixed (00h) ;changes affect window positions?  ;bit1=jitters!   ;bit4-7:NOT R/W
 dw   IO_OSD_whatever_FB62h        // db 0   ;-whatever (bit0 cleared by firmware)
 dw   IO_OSD_char_xsiz             // db 08h ;\character x/y size in pixels
 dw   IO_OSD_char_ysiz             // db 08h ;/(xsiz max 24pix?)
 dw   IO_OSD_xyflip                // db 00h ;-bit4:TileXflip, bit5:MapXflip, bit6:TileYflip, bit7:MapYflip, lower4bit=?
;---
 dw   IO_OSD_window_0_size_x       // db 0   ;\
 dw   IO_OSD_window_0_size_y       // db 0   ;
 dw   IO_OSD_window_0_xyloc_msb    // db 0   ; window 0
 dw   IO_OSD_window_0_xloc_lsb     // db 0   ;
 dw   IO_OSD_window_0_yloc_lsb     // db 0   ;/
 dw   IO_OSD_window_1_size_x       // db 0   ;\
 dw   IO_OSD_window_1_size_y       // db 0   ;
 dw   IO_OSD_window_1_xyloc_msb    // db 0   ; window 1
 dw   IO_OSD_window_1_xloc_lsb     // db 0   ;
 dw   IO_OSD_window_1_yloc_lsb     // db 0   ;
 dw   IO_OSD_window_1_vramaddr_lsb // db 0   ;/
 dw   IO_OSD_window_2_size_x       // db 0   ;\
 dw   IO_OSD_window_2_size_y       // db 0   ;
 dw   IO_OSD_window_2_xyloc_msb    // db 0   ; window 2
 dw   IO_OSD_window_2_xloc_lsb     // db 0   ;
 dw   IO_OSD_window_2_yloc_lsb     // db 0   ;
 dw   IO_OSD_window_2_vramaddr_lsb // db 0   ;/
 dw   IO_OSD_window_3_size_x       // db 0   ;\
 dw   IO_OSD_window_3_size_y       // db 0   ;
 dw   IO_OSD_window_3_xyloc_msb    // db 0   ; window 3
 dw   IO_OSD_window_3_xloc_lsb     // db 0   ;
 dw   IO_OSD_window_3_yloc_lsb     // db 0   ;
 dw   IO_OSD_window_3_vramaddr_lsb // db 0   ;/
 dw   IO_OSD_window_4_size_x       // db 0   ;\
 dw   IO_OSD_window_4_size_y       // db 0   ;
 dw   IO_OSD_window_4_xyloc_msb    // db 0   ; window 4
 dw   IO_OSD_window_4_xloc_lsb     // db 0   ;
 dw   IO_OSD_window_4_yloc_lsb     // db 0   ;
 dw   IO_OSD_window_4_vramaddr_lsb // db 0   ;/
;---
 dw   IO_OSD_window_0_vscale_upper // db 00h ;\
 dw   IO_OSD_window_0_vscale_upmid // db 00h ;
 dw   IO_OSD_window_0_vscale_lomid // db 00h ;
 dw   IO_OSD_window_0_vscale_lower // db 00h ;/
 dw   IO_OSD_window_0_hscale_left  // db 00h ;\
 dw   IO_OSD_window_0_hscale_mid   // db 00h ;
 dw   IO_OSD_window_0_hscale_right // db 00h ;/
 dw   IO_OSD_window_0_scale        // db 00h ;\
 dw   IO_OSD_window_1_and_2_scale  // db 00h ;
 dw   IO_OSD_window_3_and_4_scale  // db 00h ;/
;dw   IO_OSD_bitmap_colors... defs 32 ;sixteen words (20h bytes) (used only by an UNUSED function) maybe 16-color bitmap palette?  ;\EVEN ADDRESSES: bit4-7:NOT R/W
 dw   IO_OSD_color_1_msb           // db 000h ;fixed (00h)  ;\00h,0Fh red
 dw   IO_OSD_color_1_lsb           // db 00Fh ;fixed (0Fh)  ;/
 dw   IO_OSD_color_2_msb           // db 000h ;fixed (00h)  ;\00h,F0h green
 dw   IO_OSD_color_2_lsb           // db 0F0h ;fixed (F0h)  ;/
 dw   IO_OSD_color_3_msb           // db 00Fh ;fixed (0Fh)  ;\0Fh,00h blue
 dw   IO_OSD_color_3_lsb           // db 000h ;fixed (00h)  ;/
 dw   IO_OSD_color_4_msb           // db 000h ;fixed (00h)  ;\00h,FFh yellow
 dw   IO_OSD_color_4_lsb           // db 0FFh ;fixed (FFh)  ;/
 dw   IO_OSD_color_5_msb           // db 00Fh ;fixed (0Fh)  ;\0Fh,F0h cyan
 dw   IO_OSD_color_5_lsb           // db 0F0h ;fixed (F0h)  ;/
 dw   IO_OSD_color_6_msb           // db 00Fh ;fixed (0Fh)  ;\0Fh,FFh white
 dw   IO_OSD_color_6_lsb           // db 0FFh ;fixed (FFh)  ;/
 db   iolist_endcode
;------------------
main_init:
 call main_init_part_1          ;-init ...
 call main_init_part_2          ;-init timers
 call main_init_part_3          ;-select root & load settings
 call main_init_part_4          ;-init VARIOUS stuff
 call main_init_part_5          ;-display spi reset/init
 set  ea         ;XXXsfr
 ret
;------------------
main_init_part_1:
 or   [SFR_IO_memory_system],80h  ;bit7 ;-
 mov  dptr,IO_PLL_0Eh_used              ;\
 mov  a,20h                             ;
 movx [dptr],a                          ;/
 ret
;------------------
main_init_part_2:      ;init timers
 call watchdog_disable
 call init_lcd_pins_and_force_display_off
 call init_timer_hardware
 call set_baudrate_57600bps
 call watchdog_enable
 jmp  init_ack_irqs
;------------------
main_init_part_3:   ;select root & load settings
 call init_variables            ;-
 call detect_flash_chiptype     ;-
 call init_load_settings        ;-load settings
 ret
;------------------
main_init_part_4:    ;init VARIOUS stuff
 call init_part_4_subfunc       ;...init I/O
 call init_OSD_hardware
.if with_infrared
   call init_IR_hardware
.endif
 call init_ADC_analog_hardware
;call xxx_B212h      ;...init/copy some XRAM stuff (keyboard related)
 call init_AV_stuff
 call apply_settings_to_IO_ports_except_backlight
 ret
;------------------
main_init_part_5:
 call display_spi_reset         ;reset SPI
 call display_spi_detect
 call display_spi_dump_initial
 jmp  display_spi_init          ;display SPI init
;------------------
init_variables:
 mov  a,0FFh                            ;-
 mov  dptr,xram_new_detected_video      ;\
 movx [dptr],a   ;=FFh                  ;/
 mov  [iram_ir_msb_device],a  ;=FFh     ;\
 mov  [iram_ir_lsb_cmd],a     ;=FFh     ;/
 clr  a                                 ;\
 mov  dptr,xram_palntsc_same_counter    ;
 movx [dptr],a                          ;/
 ret
;------------------
init_timer_hardware:
 clr  tr0         ;XXXsfr  ;Timer 0 Run (Stop)
 clr  tr1         ;XXXsfr  ;Timer 1 Run (Stop)
 mov  [SFR_IO_TMOD],11h ;timer0/1: both 16bit, increment at fCLK/12 ? (27MHz/12 = 2.25MHz?)
 mov  [SFR_IO_timer0_msb],0FBh  ;\FB9Fh aka -461h (-1121)   ;\Timer0  ;ca. 2kHz ?
 mov  [SFR_IO_timer0_lsb],9Fh   ;/                          ;/
 mov  [SFR_IO_timer1_msb],0D8h  ;\D8EFh aka -2711h (-10001) ;\Timer1  ;ca. 225 Hz ?
 mov  [SFR_IO_timer1_lsb],0EFh  ;/                          ;/
 clr  a                         ;\
 mov  [SFR_IO_timer3_lsb],a ;\  ; reset two extra 16bit Timers
 mov  [SFR_IO_timer3_msb],a ;/  ; (though not used elsewhere)
 mov  [SFR_IO_timer4_lsb],a ;\  ;
 mov  [SFR_IO_timer4_msb],a ;/  ;/
 clr  et0         ;XXXsfr  ;Timer 0 Overflow Interrupt (off)
 set  et1         ;XXXsfr  ;Timer 1 Overflow Interrupt (on)
 clr  tr0         ;XXXsfr  ;Timer 0 Run (Stop)
 set  tr1         ;XXXsfr  ;Timer 1 Run (Run)
 ret
;------------------
init_ack_irqs:
 clr  ea          ;XXXsfr  ;Global Interrupt Enable (0=Off)
 mov  a,0003h                                   ;\
 mov  dptr,firm_irq_0003h_ext_int0_infrared     ;
 call set_irq_vector_a_to_dptr                  ;/
 mov  a,001Bh                                   ;\
 mov  dptr,firm_irq_001Bh_timer_1_overflow      ;
 call set_irq_vector_a_to_dptr                  ;/
 mov  a,0043h                                   ;\
 mov  dptr,firm_irq_0043h_adc_keypad            ;
 call set_irq_vector_a_to_dptr                  ;/
 mov  a,005Bh                                   ;\
 mov  dptr,firm_irq_005Bh_framerate             ;
 call set_irq_vector_a_to_dptr                  ;/
;- - -
 mov  [SFR_IO_ipc],00h  ;XXXsfr   ;Interrupt Priority Register
 set  it0         ;XXXsfr  ;External Interrupt 0 Type (0=Low)
 clr  ie0         ;XXXsfr  ;External Interrupt 0 Flag (0=Ack)
 and  [SFR_IO_xxx91h],0EFh  ;not 10h  ;bit4=0  ;ack extra irq's
 and  [SFR_IO_xxx91h],0DFh  ;not 20h  ;bit5=0
 and  [SFR_IO_xxx91h],0BFh  ;not 40h  ;bit6=0
 and  [SFR_IO_xxx91h],7Fh   ;not 80h  ;bit7=0
 clr  [SFR_IO_xxxF8h].0                 ;\
 set  [SFR_IO_xxxF8h].1 ;<--set         ;
 clr  [SFR_IO_xxxF8h].2                 ;
 clr  [SFR_IO_xxxF8h].3                 ;
;clr  [SFR_IO_xxxF8h].4                 ;/
.if with_infrared=0
   clr  ex0     ;XXXsfr  ;External Interrupt 0 Enable (0=Off)
.else
   set  ex0     ;XXXsfr  ;External Interrupt 0 Enable (1=On) (infrared)
.endif
.if with_keypad_irq                     ;\
   set  [SFR_IO_IEC2].0    ;adc.irq     ;
.else                                   ;
   clr  [SFR_IO_IEC2].0    ;adc.irq     ; interrupt enable flags
.endif                                  ;
 clr  [SFR_IO_IEC2].1                   ;
 clr  [SFR_IO_IEC2].2                   ;
 set  [SFR_IO_IEC2].3      ;vblank      ;
;clr  [SFR_IO_IEC2].4      ;timer3/4    ;/
 ret
;------------------
init_part_4_subfunc:    ;init I/O ...
 call init_part_4_subsubfunc                            ;-
 call output_initial_data_from_extra_fixed_io_list      ;-
 call init_io_via_huge_fixed_io_list            ;-huge I/O init
;- - -
 clr  a                                 ;\initially select AV1 (just to have
 mov  dptr,xram_curr_input              ; a stable state) (actual selection
 movx [dptr],a                          ; will be done in IRQ handler)
 call apply_av_input_a                  ;/
;- - -
 mov  dptr,IO_PLL_0Eh_used              ;\
 mov  a,2Ch                             ; eats up around 21mA
 movx [dptr],a                          ;/
    .comment
     ;below looks nonsense (might be needed/useful when leaving standby...?)
     mov  a,64h                             ;\delay 100
     call firm_wait_a_milliseconds          ;/
     mov  dptr,IO_AV_force_resync           ;\
     movx a,[dptr]                          ;
     or   a,01h     ;set bit0               ;
     movx [dptr],a                          ;/
     mov  a,0Ah                             ;\delay 10
     call firm_wait_a_milliseconds          ;/
     mov  dptr,IO_AV_force_resync           ;\
     movx a,[dptr]                          ;
     and  a,0FEh    ;clear bit0             ;
     movx [dptr],a                          ;/
     mov  a,32h                             ;\delay 50
     jmp  firm_wait_a_milliseconds          ;/
    .comment
 ret
;------------------
init_part_4_subsubfunc:   ;SUBFUNC of... init_part_4_subfunc
 or   [SFR_IO_whatever_config],07h      ;-  XXX
 mov  dptr,@@io_list_1                  ;\list 1
 call init_io_via_io_list               ;/
 mov  dptr,IO_PLL_19h_used              ;\
 movx a,[dptr]                          ; (later set to 83h)
 or   a,81h                             ;
 movx [dptr],a                          ;/
 mov  dptr,@@io_list_2                  ;\list 2
 call init_io_via_io_list               ;/
 mov  dptr,IO_AV_ctrl_whatever_1        ;\
 movx a,[dptr]                          ;
 or   a,02h     ;bit1=1                 ;
 movx [dptr],a                          ;/
 mov  dptr,@@io_list_3                  ;\list 3
 call init_io_via_io_list               ;/
 ret
;---
@@io_list_1:
 dw   IO_PLL_0Eh_used           // db 020h
 dw   IO_PLL_11h_used           // db 0FFh
 dw   IO_PLL_12h_used           // db 0FFh
 dw   IO_PLL_13h_used           // db 0FFh
 dw   IO_PLL_0Bh_used           // db 040h
 dw   IO_PLL_10h_cfg            // db 004h  ;<-- also set to 04h, too, elsewhere
 db   iolist_endcode
;---
@@io_list_2:
 dw   IO_whatever_FD50h         // db 000h  ;<-- set to 00h (but set to 0Bh elsewhere)
 dw   IO_whatever_zerofilled+0  // db 000h
 dw   IO_whatever_zerofilled+1  // db 000h
 dw   IO_whatever_zerofilled+2  // db 000h
 dw   IO_whatever_zerofilled+3  // db 000h
 dw   IO_whatever_zerofilled+4  // db 000h
 dw   IO_whatever_zerofilled+5  // db 000h
 dw   IO_whatever_zerofilled+6  // db 000h
 dw   IO_whatever_zerofilled+7  // db 000h
 dw   IO_whatever_zerofilled+8  // db 000h
 dw   IO_whatever_zerofilled+9  // db 000h
 dw   IO_LCD_whatever_FFCBh     // db 080h  ;<-- set to 2Ah elsewhere
 dw   IO_LCD_config_FFCCh       // db 080h
 dw   IO_LCD_config_FFCDh       // db 02Dh
 dw   IO_LCD_config_FFB7h       // db 090h
 dw   IO_LCD_whatever_FFD8h     // db 080h
 dw   IO_LCD_config_FFD7h       // db 010h
;dw   IO_LCD_backdrop_color_Y   // db 013h  ;\
;dw   IO_LCD_backdrop_color_Cb  // db 0DDh  ; backdrop color (BLUE)
;dw   IO_LCD_backdrop_color_Cr  // db 072h  ;/
 db   iolist_endcode
;---
@@io_list_3:
 dw   IO_AV_video_on_off        // db 0F7h
 dw   IO_AV_config_FEBAh        // db 0FFh
 dw   IO_AV_config_FEB5h        // db 067h
 dw   IO_AV_ctrl_sensitivity_1  // db 0B1h  ;<-- eats up 2mA
 dw   IO_AV_config_FE56h        // db 000h
 dw   IO_AV_config_FE13h        // db 01Eh
 dw   IO_VIDEO_something_3      // db 001h
 dw   IO_VIDEO_something_4      // db 045h
 db   iolist_endcode
;------------------
init_AV_stuff:
 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ;
 or   a,1Ch   ;bit2,3,4 = set           ;
 movx [dptr],a                          ;/
 inc  dptr ;=IO_AV_input_select_reg_0   ;\
 movx a,[dptr]                          ;
 or   a,1Bh   ;bit0,1,3,4 = set         ;
 and  a,0DBh  ;bit2,5 = clear           ;
 movx [dptr],a                          ;/
 inc  dptr ;=IO_AV_config_FED9h_bits    ;\
 movx a,[dptr]                          ;
 and  a,0CFh    ;bit4-5=00b             ;
 or   a,40h     ;bit6=1                 ;
 movx [dptr],a                          ;/
 mov  dptr,IO_AV_config_FEDBh_bit       ;\
 movx a,[dptr]                          ;
 and  a,7Fh     ;bit7=0                 ;
 movx [dptr],a                          ;/
 mov  dptr,IO_AV_ctrl_whatever_1        ;\
 movx a,[dptr]                          ;
 or   a,10h     ;bit4=1                 ;
 movx [dptr],a                          ;/
 mov  dptr,IO_AV_config_FE04h           ;\
 mov  a,30h     ;value 30h              ;
 movx [dptr],a                          ;/
 inc  dptr ;=IO_AV_config_FE05h         ;\
 mov  a,40h     ;value 40h              ;
 movx [dptr],a                          ;/
 ret
;------------------
;:----------------- misc code
;------------------
watchdog_enable:
 mov  [SFR_IO_watchdog_unlock],55h              ;-unlock
 mov  [SFR_IO_watchdog_config1],03h             ;\
 mov  [SFR_IO_watchdog_config3],8Fh             ; init
 mov  [SFR_IO_watchdog_config2],0FFh            ;/
 mov  [SFR_IO_watchdog_enable],01h              ;-enable
 mov  [SFR_IO_watchdog_unlock],0AAh             ;-lock
 ret
;------------------
watchdog_disable:
 mov  [SFR_IO_watchdog_unlock],55h              ;-unlock
 mov  [SFR_IO_watchdog_enable],00h              ;-disable
 mov  [SFR_IO_watchdog_unlock],0AAh             ;-lock
 ret
;------------------
watchdog_reload:
 mov  [SFR_IO_watchdog_unlock],55h              ;-unlock
 mov  [SFR_IO_watchdog_reload],0BBh             ;\
 xor  [SFR_IO_watchdog_reload],0FFh  ;xor!      ; reload
 mov  [SFR_IO_watchdog_reload],00h              ;/
 mov  [SFR_IO_watchdog_unlock],0AAh             ;-lock
 ret
;------------------
firm_wait_a_milliseconds:
 push r0(0)
@@lop:
 mov  r0,0d0h             ;\
 djnz r0,$  ;0D0h = 88us  ;
 djnz r0,$  ;100h = 114us ;
 djnz r0,$  ;100h = 114us ;
 djnz r0,$  ;100h = 114us ; 88+8x114
 djnz r0,$  ;100h = 114us ; =1000us
 djnz r0,$  ;100h = 114us ;
 djnz r0,$  ;100h = 114us ;
 djnz r0,$  ;100h = 114us ;
 djnz r0,$  ;100h = 114us ;/
 djnz a,@@lop
 pop  r0(0)
 ret
;------------------
;:----------------- *** SYSGUI ***
;------------------
        smallfont equ 1
;------------------
sysgui_txt_100          db '100',0
;------------------
sysgui_menu_list:
 dw 0
sysgui_index_main_menu equ ($-sysgui_menu_list)/2
 dw sysgui_item_backlight
 dw sysgui_item_brightness
 dw sysgui_item_contrast
 dw sysgui_item_saturation
 dw sysgui_item_tint
 dw sysgui_item_volume
 dw sysgui_item_input
 dw sysgui_item_no_signal
 dw sysgui_item_ratio
 dw sysgui_item_keypadtype
 dw sysgui_item_panel_type
 dw sysgui_item_rgb_ramps
 dw sysgui_item_yuv_consts
 dw sysgui_item_pal_ntsc
 dw sysgui_item_allow_c64
 dw sysgui_item_tianma_r0f
 dw sysgui_item_xyflip
 dw sysgui_item_magic_floor
 dw sysgui_item_diag
 dw sysgui_item_about
 dw 0
sysgui_num_menu_indices    equ ($-sysgui_menu_list)/2
;------------------
sysgui_item_backlight   dw xram_sett_backlight    // db 'BACKLIGHT',0  ,'%',0
sysgui_item_brightness  dw xram_sett_brightness   // db 'BRIGHTNESS',0 ,'%',0
sysgui_item_contrast    dw xram_sett_contrast     // db 'CONTRAST',0   ,'%',0
sysgui_item_saturation  dw xram_sett_saturation   // db 'SATURATION',0 ,'%',0
sysgui_item_tint        dw xram_sett_tint         // db 'TINT (NTSC)',0,'%',0
sysgui_item_volume      dw xram_sett_volume       // db 'VOLUME',0     ,'%',0
sysgui_item_input       dw xram_sett_input        // db 'INPUT',0      ,'AV1+AV2 (AV1 PREFERRED)',0,'AV2+AV1 (AV2 PREFERRED)',0,'AV1 ONLY',0,'AV2 ONLY',0,'.',0
sysgui_item_no_signal   dw xram_sett_no_signal    // db 'NO SIGNAL',0  ,'STANDBY',0,'BLUE SCREEN',0,'BLUE+SNOW',0,'BLACK+SNOW',0,'.',0
sysgui_item_ratio       dw xram_sett_ratio        // db 'RATIO',0      ,'4:3',0,'16:9',0,'.',0
sysgui_item_keypadtype  dw xram_sett_keypadtype   // db 'KEYPAD TYPE',0   ,'3KEY +MENU- (NORMAL)',0,'3KEY -MENU+ (SWAPPED)',0,'.',0
sysgui_item_panel_type  dw xram_sett_panel_type   // db 'DISPLAY PANEL',0 ,'TIANMA 320*240',0,'INNOLUX 480*272',0,'.',0
sysgui_item_xyflip      dw xram_sett_xyflip       // db 'FLIP/ROTATE',0,'NORMAL',0,'X-FLIP',0,'Y-FLIP',0,'Y/X-FLIP (ROTATE)',0,'.',0
sysgui_item_rgb_ramps   dw xram_sett_rgb_ramps    // db 'RGB GAMMA RAMPS',0,'NEW',0,'OLD',0,'LINEAR',0,'.',0
sysgui_item_yuv_consts  dw xram_sett_yuv_consts   // db 'YUV CONTANTS'   ,0,'NEW',0,'OLD',0,'.',0
sysgui_item_pal_ntsc    dw xram_sett_pal_ntsc     // db 'SIGNAL DECODING',0,'PAL/NTSC',0,'PAL/PAL60',0,'.',0
sysgui_item_allow_c64   dw xram_sett_allow_c64    // db 'C64 VIDEO SIGNAL',0,'ACCEPT',0,'REFUSE',0,'.',0
sysgui_item_tianma_r0f  dw xram_sett_tianma_r0f   // db 'TIANMA VOLTAGES',0,'CORRECT/RECOMMENDED',0,'INCORRECT/DEFAULT',0,'.',0
sysgui_item_magic_floor dw magic_floor_game       // db 'MAGIC FLOOR',0,'@',0
sysgui_item_diag        dw nocash_test_entrypoint // db 'AMT630 DIAG',0,'@',0
sysgui_item_about       dw sysgui_about_screen    // db 'ABOUT',0      ,'@',0
;------------------
firm_skipstr:
@@lop:
 clr  a
 movc a,[a+dptr]
 inc  dptr
 jnz  a,@@lop
 ret
;------------------
firm_read_ba_from_dptr:
 clr  a
;- - - - - --------
firm_read_ba_from_dptr_plus_a:
 mov  b,a
 movc a,[a+dptr]
 xchg a,b
 inc  a
 movc a,[a+dptr]
 ret
;------------------
firm_read_dptr_from_dptr:
 clr  a
;- - - - - --------
firm_read_dptr_from_dptr_plus_a:
 mov  b,a
 movc a,[a+dptr]
 xchg a,b
 inc  a
 movc a,[a+dptr]
 mov  dpl,a
 mov  dph,b
 ret
;------------------
sysgui_prompt_panel_type:
 mov  dptr,IO_OSD_window_enable_bits // mov a,00h   // movx [dptr],a

 mov  dptr,IO_OSD_window_0_size_x    // mov a,40    // movx [dptr],a
 mov  dptr,IO_OSD_window_0_size_y    // mov a,8     // movx [dptr],a
 mov  dptr,IO_OSD_bitmap_transp_misc // mov a,00h   // movx [dptr],a

 mov  dptr,IO_OSD_window_0_size_x       ;\
 mov  a,20                              ;
 call set_window_xloc                   ;/
 mov  dptr,IO_OSD_window_0_size_x       ;\
 mov  a,30                              ;
 call set_window_yloc                   ;/

 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; AV (disables snow and AV input)
 and  a,not 1                           ;
 movx [dptr],a                          ;/

 mov  dptr,0                    ;\
 call firm_set_bgmap_addr       ;/
 mov  dptr,txt_panel1           ;\
 call sysgui_wrstr              ;/
 mov  dptr,2*40                 ;\
 call sysgui_space_pad          ;/
 mov  dptr,txt_panel2           ;\
 call sysgui_wrstr              ;/
 mov  dptr,8*40                 ;\
 call sysgui_space_pad          ;/

 mov  dptr,IO_OSD_window_enable_bits // mov a,80h+1     // movx [dptr],a
;- - -
 mov  r0,0
@@flasher_lop:
 inc  r0                                ;\
 mov  a,r0                              ;
 ror  a                                 ;
 ror  a                                 ;
 and  a,01h                             ;
 mov  dptr,xram_sett_panel_type         ;
 movx [dptr],a                          ;
 push r0(0)                             ;
 call apply_settings_to_IO_ports        ;
 pop  r0(0)                             ;/
 call getkey_with_keyrepeat             ;\
 and  a,1+4                             ;
 jz   a,@@flasher_lop                   ;/
;- - -
@@key_lop:
 call getkey_with_keyrepeat
 jnz  a.1,@@done
 jz   a,@@key_lop
 mov  dptr,xram_sett_panel_type         ;\
 movx a,[dptr]                          ;
 inc  a                                 ;
 and  a,01h                             ;
 movx [dptr],a                          ;
 call apply_settings_to_IO_ports        ;/
 jmp  @@key_lop
;- - -
@@done:
 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; AV (re-enable snow and AV input)
 or   a,1                               ;
 movx [dptr],a                          ;/
 ret
;---
txt_panel1 db 'USE +/- TO SELECT PANEL TYPE',0
txt_panel2 db 'PRESS MENU WHEN DONE',0
;------------------
sysgui_about_screen:
 mov  dptr,IO_OSD_window_enable_bits // mov a,00h   // movx [dptr],a

 mov  dptr,IO_OSD_window_0_size_x    // mov a,40    // movx [dptr],a
 mov  dptr,IO_OSD_window_0_size_y    // mov a,8     // movx [dptr],a
 mov  dptr,IO_OSD_bitmap_transp_misc // mov a,00h   // movx [dptr],a

 mov  dptr,IO_OSD_window_0_size_x       ;\
 mov  a,20                              ;
 call set_window_xloc                   ;/
 mov  dptr,IO_OSD_window_0_size_x       ;\
 mov  a,30                              ;
 call set_window_yloc                   ;/

 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; AV (disables snow and AV input)
 and  a,not 1                           ;
 movx [dptr],a                          ;/

 mov  dptr,0                    ;\
 call firm_set_bgmap_addr       ;/
 mov  dptr,txt_about1           ;\
 call sysgui_wrstr              ;/
 mov  dptr,2*40                 ;\
 call sysgui_space_pad          ;/
 mov  dptr,txt_about2           ;\
 call sysgui_wrstr              ;/
 mov  dptr,4*40                 ;\
 call sysgui_space_pad          ;/
 mov  dptr,txt_about3           ;\
 call sysgui_wrstr              ;/
 mov  dptr,6*40                 ;\
 call sysgui_space_pad          ;/
 mov  dptr,txt_about4           ;\
 call sysgui_wrstr              ;/
 mov  dptr,8*40                 ;\
 call sysgui_space_pad          ;/

 mov  dptr,IO_OSD_window_enable_bits // mov a,80h+1     // movx [dptr],a
;- - -
@@key_lop:
 call getkey_with_fast_keyrepeat
 jz   a,@@key_lop
;- - -
 mov  dptr,IO_AV_video_on_off           ;\
 movx a,[dptr]                          ; AV (re-enable snow and AV input)
 or   a,1                               ;
 movx [dptr],a                          ;/
 jmp  sysgui_select_menu                ;-back to menu
;---
txt_about1 db 'NOCASH AMT630A FIRMWARE V1.0',0
txt_about2 db 'COPYRIGHT 2018 MARTIN KORTH',0
txt_about3 db 'http://problemkaputt.de/amt630a.htm',0
txt_about4 db '(all lowercase)',0
;------------------
sysgui_draw_item_name:
 mov  dptr,0000h
 call firm_set_bgmap_addr
 mov  a,'>'
 call sysgui_wrchr
 call sysgui_wrspc
 mov  dph,[iram_sysgui_menu_text_msb]
 mov  dpl,[iram_sysgui_menu_text_lsb]
 call sysgui_wrstr
 ret
;------------------
sysgui_draw_item_state:
 push a
 mov  dptr,0000h+32                     ;\
 call firm_set_bgmap_addr               ;/
 pop  a
 call sysgui_wrchr
 mov  dph,[iram_sysgui_menu_text_msb]
 mov  dpl,[iram_sysgui_menu_text_lsb]
 call firm_skipstr
 clr  a
 movc a,[a+dptr]
 jne  a,'%',@@not_bar
 mov  dph,[iram_sysgui_menu_param_msb]
 mov  dpl,[iram_sysgui_menu_param_lsb]
 movx a,[dptr]
 call sysgui_draw_bar
 sjmp @@finish
;---
@@not_bar:
 jne  a,'@',@@not_proc
 sjmp @@finish
;---
@@not_proc:
 call sysgui_wrspc
 mov  dph,[iram_sysgui_menu_param_msb]
 mov  dpl,[iram_sysgui_menu_param_lsb]
 movx a,[dptr]
 inc  a
 mov  r0,a
 mov  dph,[iram_sysgui_menu_text_msb]
 mov  dpl,[iram_sysgui_menu_text_lsb]
@@find_name_lop:
 call firm_skipstr
 djnz r0,@@find_name_lop
 call sysgui_wrstr
 sjmp @@finish
;---
@@finish:
 mov  dptr,0000h+32+100/4+6     ;\
 call sysgui_space_pad          ;/
 ret
;------------------
sysgui_get_menu_ptr:
 mov  dptr,sysgui_menu_list             ;\
 mov  a,[iram_sysgui_menu_index]        ;
 add  a,a                               ;
 call firm_read_dptr_from_dptr_plus_a   ;/
 call firm_read_ba_from_dptr            ;\
 mov  [iram_sysgui_menu_param_msb],b    ;
 mov  [iram_sysgui_menu_param_lsb],a    ;/
 inc  dptr
 inc  dptr
 mov  [iram_sysgui_menu_text_msb],dph
 mov  [iram_sysgui_menu_text_lsb],dpl
 ret
;------------------
verify_loaded_settings:
 mov  dptr,xram_sett_id_5Ah             ;\
 movx a,[dptr]                          ; verify start ID
 jne  a,05Ah,@@bad_id_5Ah_A5h           ;/
 mov  dptr,xram_sett_id_A5h             ;\
 movx a,[dptr]                          ; verify end ID
 jne  a,0A5h,@@bad_id_5Ah_A5h           ;/
 call firm_calc_settings_chksum         ;\
 mov  r0,a     ;calculated chk          ;
 mov  dptr,xram_sett_chksum             ; verify settings chksum
 movx a,[dptr]                          ;
 jne  a,r0(0),@@bad_chksum              ;/
;- - -

 mov  [iram_sysgui_menu_index],0
@@lop:
 call sysgui_count_num_options_r0
 jc   @@skip
 mov  dph,[iram_sysgui_menu_param_msb]
 mov  dpl,[iram_sysgui_menu_param_lsb]
 movx a,[dptr]
 clr  c
 sbc  a,r0      ;max
 jnc  @@found_bad_setting
@@skip:
 inc  [iram_sysgui_menu_index]          ;\
 mov  a,[iram_sysgui_menu_index]        ;
 jne  a,sysgui_num_menu_indices,@@lop   ;/
 set  c    ;out: cy=1=okay
 ret
 ret
;---
@@found_bad_setting:
@@bad_id_5Ah_A5h:
@@bad_chksum:
 clr  c    ;out: cy=0=bad
 ret
;------------------
sysgui_check_null_item:
 mov  dptr,sysgui_menu_list             ;\
 mov  a,[iram_sysgui_menu_index]        ;
 add  a,a                               ;
 call firm_read_dptr_from_dptr_plus_a   ;
 mov  a,dph                             ;
 or   a,dpl                             ;/
 ret
;------------------
sysgui_count_num_options_r0:
 call sysgui_check_null_item            ;\
 jz   a,@@skip_spacer                   ;/

 call sysgui_get_menu_ptr
 call firm_skipstr
 clr  a
 movc a,[a+dptr]
 jne  a,'%',@@not_bar   ;\
 mov  r0,101    ;max    ; bar
 sjmp @@this_max        ;
@@not_bar:              ;/
 jne  a,'@',@@not_jump  ;\
 sjmp @@skip_jump       ; jump
@@not_jump:             ;/

 mov  r0,00h    ;max            ;\
@@count_max_lop:                ;
 call firm_skipstr              ;
 inc  r0        ;max            ;
 clr  a                         ;
 movc a,[a+dptr]                ;
 jne  a,'.',@@count_max_lop     ;/
@@this_max:
 clr  c
 ret
;---
@@skip_jump:
@@skip_spacer:
 set  c
 ret
;------------------
firm_check_signal:
 mov  dptr,IO_AV_stat_detect_0
 movx a,[dptr]
 mov  c,a.1
 ret
;------------------
sysgui_standby:
 mov  dptr,IO_OSD_window_enable_bits // mov a,00h // movx [dptr],a  ;hide OSD
;- - -
 mov  dptr,xram_sett_no_signal          ;\
 movx a,[dptr]                          ;
 jnz  a,@@wake                          ;/
;- - -
;@@standby:
 call switch_screen_and_backlight_off
@@standby_lop:                          ;\

 mov  a,[SFR_IO_PCON]  ;equ 087h    ;bit0-1:DANGER(halt/idle?), bit2-3,6-7:R/W, bit4-5:NOT R/W
 or   a,1   ;doesn't reduce power
 ;or  a,2   ;HANGS, ie. disables timer irqdoesn't reduce power (and )
 mov  [SFR_IO_PCON],a

 call getkey_with_keyrepeat             ;\
 jnz  a,@@enter_menu                    ;/

 mov  dptr,IO_AV_stat_signal_detect     ;\         ;see input_selector
 movx a,[dptr]  ;test deselected input  ;
 jz   a.6,@@standby_lop                 ;/

;;; call firm_check_signal                 ;
;;; jnc  @@standby_lop                     ;/
;- - -
@@wake:
 call switch_screen_and_backlight_on
 mov  a,64h                             ;\delay 100 (allow input_selector to find something)
 call firm_wait_a_milliseconds          ;/
 sjmp sysgui_idle
;---
@@enter_menu:
 call switch_screen_and_backlight_on
 jmp  sysgui_select_menu
;------------------
sysgui_idle:
 mov  dptr,IO_OSD_window_enable_bits // mov a,00h // movx [dptr],a  ;hide OSD
@@idle_lop:                             ;\
 call getkey_with_keyrepeat             ;
 jnz  a,@@enter_menu                    ;/
 mov  dptr,xram_sett_no_signal          ;\
 movx a,[dptr]                          ;
 jnz  a,@@idle_lop                      ;/
 call firm_check_signal                 ;\
 jc   @@idle_lop                        ;/
 sjmp sysgui_standby
;---
@@enter_menu:
 jmp  sysgui_select_menu
;------------------
set_window_xloc:
 ;in: a=xloc  ;0..7Fh=from upper/left, 80h=centered, -1..-7Fh=from lower/right
 ;in: dptr=window base (and window sizes values already initialized)
 mov  r0,a  ;xloc
 mov  r1,0  ;xloc.msb
 jz   a.7,@@from_upper_left
   ;XXX when a=80h: use "(screen_width-window.width)/2"
 call firm_get_screen_width_ba          ;-ba=screen.width
 add  a,r0                              ;\
 mov  r0,a                              ;
 mov  a,b                               ; r1r0=screen.width+(-xloc)
 adc  a,0ffh  ;sign-expanded            ;
 mov  r1,a                              ;/
@@from_upper_left:
;- - -
 call get_xflip_flag
 jnc  @@no_xflip
 movx a,[dptr] ;IO_OSD_window_#_size_x  ;\
 mov  b,8       ;font.xsize             ; ba=window.width
 mul  a,b                               ;/
 add  a,r0                              ;\
 mov  r0,a                              ;
 mov  a,b                               ; r1r0=window.width+xloc
 adc  a,r1                              ;
 mov  r1,a                              ;/
 call firm_get_screen_width_ba          ;-ba=screen.width
 clr  c                                 ;\
 sbc  a,r0                              ;
 mov  r0,a                              ; r1r0=screen.width-(window.width+xloc)
 mov  a,b                               ;
 sbc  a,r1                              ;
 mov  r1,a                              ;/
@@no_xflip:
;- - -
 mov  a,10  ;\                          ;\
 add  a,r0  ;                           ;
 mov  r0,a  ;/                          ; add osd base xloc
 clr  a     ;\                          ;
 adc  a,r1  ;                           ;
 mov  r1,a  ;/                          ;/
 inc  dptr     ;IO_OSD_window_#_size_y          ;\
 inc  dptr     ;IO_OSD_window_#_xyloc_msb       ;
 movx a,[dptr]                                  ;
 and  a,070h   ;yloc.msb                        ; apply xloc
 or   a,r1     ;xloc.msb                        ;
 movx [dptr],a ;IO_OSD_window_#_xyloc_msb       ;
 inc  dptr     ;IO_OSD_window_#_xloc_lsb        ;
 mov  a,r0                                      ;
 movx [dptr],a ;IO_OSD_window_#_xloc_lsb        ;/
 ret
;------------------
set_window_yloc:
 ;in: a=yloc  ;0..7Fh=from upper/left, 80h=centered, -1..-7Fh=from lower/right
 ;in: dptr=window base (and window sizes values already initialized)
 mov  r0,a  ;yloc
 mov  r1,0  ;yloc.msb
 jz   a.7,@@from_upper_left
   ;XXX when a=80h: use "(screen_height-window.height)/2"
 call firm_get_screen_height_ba         ;-ba=screen.height
 add  a,r0                              ;\
 mov  r0,a                              ;
 mov  a,b                               ; r1r0=screen.height+(-yloc)
 adc  a,0ffh  ;sign-expanded            ;
 mov  r1,a                              ;/
@@from_upper_left:
;- - -
 inc  dptr     ;IO_OSD_window_#_size_y
 call get_yflip_flag
 jnc  @@no_yflip
 movx a,[dptr] ;IO_OSD_window_#_size_y  ;\
 mov  b,9       ;font.ysize             ; ba=window.height
 mul  a,b                               ;/
 add  a,r0                              ;\
 mov  r0,a                              ;
 mov  a,b                               ; r1r0=window.height+yloc
 adc  a,r1                              ;
 mov  r1,a                              ;/
 call firm_get_screen_height_ba         ;-ba=screen.height
 clr  c                                 ;\
 sbc  a,r0                              ;
 mov  r0,a                              ; r1r0=screen.height-(window.height+yloc)
 mov  a,b                               ;
 sbc  a,r1                              ;
 mov  r1,a                              ;/
@@no_yflip:
;- - -
 mov  a,12  ;\                          ;\
 add  a,r0  ;                           ;
 mov  r0,a  ;/                          ; add osd base yloc
 clr  a     ;\                          ;
 adc  a,r1  ;                           ;
 swap a     ;                           ;
 mov  r1,a  ;/                          ;/
 inc  dptr     ;IO_OSD_window_#_xyloc_msb       ;\
 movx a,[dptr]                                  ;
 and  a,007h   ;xloc.msb                        ; apply yloc
 or   a,r1     ;yloc.msb                        ;
 movx [dptr],a ;IO_OSD_window_#_xyloc_msb       ;
 inc  dptr     ;IO_OSD_window_#_xloc_lsb        ;
 inc  dptr     ;IO_OSD_window_#_yloc_lsb        ;
 mov  a,r0                                      ;
 movx [dptr],a ;IO_OSD_window_#_yloc_lsb        ;/
 ret
;------------------
get_xflip_flag:
 push a
 push dpl
 push dph
 mov  dptr,xram_sett_xyflip
 movx a,[dptr]
 mov  c,a.0
 pop  dph
 pop  dpl
 pop  a
 ret
;------------------
get_yflip_flag:
 push a
 push dpl
 push dph
 mov  dptr,xram_sett_xyflip
 movx a,[dptr]
 mov  c,a.1
 pop  dph
 pop  dpl
 pop  a
 ret
;------------------
firm_get_screen_width_ba:
 push dpl                                       ;\
 push dph                                       ;
 mov  dptr,xram_sett_panel_type                 ;
 movx a,[dptr]                                  ;
 pop  dph                                       ;
 pop  dpl                                       ;/
 jz   a,@@size_320x240
;---
@@size_480x272:
 mov  b,480/100h
 mov  a,480 and 0ffh
 ret
;---
@@size_320x240:
 mov  b,320/100h
 mov  a,320 and 0ffh
 ret
;------------------
firm_get_screen_height_ba:
 push dpl                                       ;\
 push dph                                       ;
 mov  dptr,xram_sett_panel_type                 ;
 movx a,[dptr]                                  ;
 pop  dph                                       ;
 pop  dpl                                       ;/
 jz   a,@@size_320x240
;---
@@size_480x272:
 mov  b,272/100h
 mov  a,272 and 0ffh
 ret
;---
@@size_320x240:
 mov  b,240/100h
 mov  a,240 and 0ffh
 ret
;------------------
sysgui_apply_window_positions:
 mov  dptr,IO_OSD_window_0_size_x       ;\
 mov  a,12                              ;
 call set_window_xloc                   ;/
 mov  dptr,IO_OSD_window_1_size_x       ;\
 mov  a,12                              ;
 call set_window_xloc                   ;/
 mov  dptr,IO_OSD_window_0_size_x       ;\
 mov  a,-30                             ;
 call set_window_yloc                   ;/
 mov  dptr,IO_OSD_window_1_size_x       ;\
 mov  a,-15                             ;
 call set_window_yloc                   ;/
 ret
;------------------
sysgui_select_menu:
 mov  dptr,IO_OSD_window_0_size_x    // mov a,32    // movx [dptr],a   ;\
 mov  dptr,IO_OSD_window_0_size_y    // mov a,1     // movx [dptr],a   ;/
 mov  dptr,IO_OSD_window_1_size_x    // mov a,100/4+6 // movx [dptr],a ;\
 mov  dptr,IO_OSD_window_1_size_y    // mov a,1     // movx [dptr],a   ;
 mov  dptr,IO_OSD_window_1_vramaddr_lsb // mov a,32 // movx [dptr],a   ;/
 mov  dptr,IO_OSD_bitmap_transp_misc // mov a,00h   // movx [dptr],a
 call sysgui_apply_window_positions
 mov  dptr,IO_OSD_window_enable_bits // mov a,80h+1+2   // movx [dptr],a
@@time equ 200

@@outer_lop:
 mov  [iram_sysgui_timeout],@@time
 call sysgui_get_menu_ptr

 call sysgui_draw_item_name
 mov  dptr,0000h+32             ;\
 call sysgui_space_pad          ;/
 mov  a,' '
 call sysgui_draw_item_state
@@key_lop:
 dec  [iram_sysgui_timeout]     ;\
 mov  a,[iram_sysgui_timeout]   ;
 jz   a,@@leave                 ;/
 call @@semitransp_fader
 call getkey_with_keyrepeat     ;\
 jz   a,@@key_lop               ;/
 mov  [iram_sysgui_timeout],@@time
 jnz  a.0,@@minus       ;minus/down
 jnz  a.2,@@plus        ;plus/up
 jnz  a.1,@@select      ;menu
 jmp  @@key_lop
;---
@@leave:
 jmp  sysgui_idle
;---
@@plus:
 inc  [iram_sysgui_menu_index]
 call sysgui_check_null_item            ;\
 jz   a,@@minus  ;undo inc              ;/
 jmp  @@outer_lop
;---
@@minus:
 dec  [iram_sysgui_menu_index]
 call sysgui_check_null_item            ;\
 jz   a,@@plus   ;undo dec              ;/
 jmp  @@outer_lop
;---
@@select:
 mov  dptr,0000h
 call firm_set_bgmap_addr
 call sysgui_wrspc  ;hide '>'
 mov  dph,[iram_sysgui_menu_text_msb]
 mov  dpl,[iram_sysgui_menu_text_lsb]
 call firm_skipstr
 clr  a
 movc a,[a+dptr]
 jne  a,'@',@@not_jump
 mov  dph,[iram_sysgui_menu_param_msb]
 mov  dpl,[iram_sysgui_menu_param_lsb]
 jmp  jmp_dptr
;---
@@not_jump:
 call sysgui_change_option
 jmp  @@outer_lop
;--- --- ---
@@semitransp_fader:
 mov  a,[iram_sysgui_timeout]
 clr  c
 rcr  a
 jne  a,8,$+3  ;CMP
 jnc  @@want_on
 or   a,80h  ;MSBs=brighness (normal), and LSBs=transp (1..7)
 mov  dptr,IO_OSD_bright_transp_level   ;\
 movx [dptr],a                          ;/
 mov  dptr,IO_OSD_misc_transp_enable    ;\
 mov  a,0c0h                            ; enable semitransp
 movx [dptr],a                          ;/
 ret
;---
@@want_on:
 mov  dptr,IO_OSD_misc_transp_enable    ;\
 clr  a                                 ; disable semitransp (make opaque)
 movx [dptr],a                          ;/
 ret
;------------------
sysgui_change_option:
 mov  dph,[iram_sysgui_menu_param_msb]  ;\
 mov  dpl,[iram_sysgui_menu_param_lsb]  ; memorize old state
 movx a,[dptr]                          ;
 push a         ;--> old state          ;/
@@outer_lop:
 call apply_settings_to_IO_ports
 call sysgui_apply_window_positions  ;in case xyflip or screen.size changed
 mov  a,'>'
 call sysgui_draw_item_state
 call sysgui_count_num_options_r0   ;out: r0
@@key_lop:
        push r0(0)
        call firm_mainloop_callback
        pop  r0(0)
 call getkey_with_fast_keyrepeat
 jz   a,@@key_lop
 mov  dph,[iram_sysgui_menu_param_msb]
 mov  dpl,[iram_sysgui_menu_param_lsb]
 jnz  a.0,@@minus       ;minus/down
 jnz  a.2,@@plus        ;plus/up
 jnz  a.1,@@exit        ;menu
 jmp  @@key_lop
;---
@@minus:
 movx a,[dptr]
 jz   a,@@key_lop
 dec  a
@@this:
 movx [dptr],a
 jmp  @@outer_lop
;---
@@plus:
 movx a,[dptr]
 inc  a
 jne  a,r0(0),@@this
 jmp  @@key_lop
;---
@@exit:
 mov  dph,[iram_sysgui_menu_param_msb]  ;\
 mov  dpl,[iram_sysgui_menu_param_lsb]  ;
 movx a,[dptr]                          ; check if changed
 pop  b         ;--> old state          ;
 xor  a,b                               ;
 jz   a,@@same_state                    ;/
 mov  dptr,xram_sett_backlight          ;\
 movx a,[dptr]                          ;
 jne  a,01h,$+3  ;CMP                   ; before saving, force backlight
 adc  a,0        ;change 00h to 01h     ; back to nonzero state (if needed)
 movx [dptr],a                          ;
 call apply_settings_to_IO_ports        ;/
 call firm_do_save_settings             ;-save settings
@@same_state:
 ret
;------------------
sysgui_space_pad:
 mov  r0,dpl
 mov  r1,dph
@@lop:
 mov  dptr,IO_OSD_bgmap_addr_msb
 movx a,[dptr]
 jne  a,r1(0),@@do_pad
 mov  dptr,IO_OSD_bgmap_addr_lsb
 movx a,[dptr]
 jne  a,r0(0),@@do_pad
 ret
@@do_pad:
 call sysgui_wrspc
 jmp  @@lop
;------------------
sysgui_wrstr:
@@lop:
 clr  a
 movc a,[a+dptr]
 inc  dptr
 jz   a,@@done
 call sysgui_wrchr
 jmp  @@lop
;---
@@done:
 ret
;------------------
sysgui_wrspc:
 mov  a,20h
;- - - - - --------
sysgui_wrchr:
 add  a,-20h
 jz   a.6,@@is_uppercase
 add  a,-20h
@@is_uppercase:
;- - - - - --------
sysgui_wrtile:
 push dpl
 push dph
 add  a,a    ;mul2 (for smallfont)
 mov  b,0    ;msb
 add  a,01c0h and 0ffh
 xchg a,b
 adc  a,01c0h/100h
 mov  dptr,IO_OSD_bgmap_data_msb
 movx [dptr],a
 xchg a,b
 mov  dptr,IO_OSD_bgmap_data_lsb
 movx [dptr],a
 call firm_raise_bgmap_addr
 pop  dph
 pop  dpl
 ret
;------------------
sysgui_draw_bar:
@@tile equ 40h
 push a  ;--->
 push a
 mov  a,@@tile+5
 call sysgui_wrtile
 pop  a
 mov  r0,100/4
@@xlop:
 push a
 mov  b,@@tile+0  ;empty
 jnz  a.7,@@this  ;signed
 add  a,0fch
 mov  b,@@tile+4  ;full
 jc   @@this      ;signed
 and  a,03h
 add  a,@@tile    ;part
 mov  b,a
@@this:
 mov  a,b
 call sysgui_wrtile
 pop  a
 add  a,-4
 djnz r0,@@xlop
 mov  a,@@tile+6
 call sysgui_wrtile
 pop  a  ;<---
;- - -
 jne  a,100,@@not_100
 mov  dptr,sysgui_txt_100
 jmp  sysgui_wrstr
;---
@@not_100:
 mov  b,10
 div  a,b
 jz   a,@@single_digit
 push b
 add  a,30h
 call sysgui_wrchr
 pop  a
 add  a,30h
 call sysgui_wrchr
 jmp  sysgui_wrspc
;---
@@single_digit:
 mov  a,b
 add  a,30h
 call sysgui_wrchr
 call sysgui_wrspc
 jmp  sysgui_wrspc
;------------------
firm_set_font_addr:
 push dph  ;--->
 mov  a,dpl
 mov  dptr,IO_OSD_font_addr_lsb
 movx [dptr],a
 pop  a    ;<---
 mov  dptr,IO_OSD_font_addr_msb
 movx [dptr],a
 ret
;------------------
firm_set_bgmap_addr:
 push dph  ;--->
 mov  a,dpl
 mov  dptr,IO_OSD_bgmap_addr_lsb
 movx [dptr],a
 pop  a    ;<---
 mov  dptr,IO_OSD_bgmap_addr_msb
 movx [dptr],a
 ret
;------------------
firm_raise_font_addr:
 mov  dptr,IO_OSD_font_addr_lsb ;\
 movx a,[dptr]                  ;
 inc  a                         ;
 movx [dptr],a                  ;/
 jnz  a,@@keep_msb
 mov  dptr,IO_OSD_font_addr_msb ;\
 movx a,[dptr]                  ;
 inc  a                         ;
 movx [dptr],a                  ;/
@@keep_msb:
 ret
;------------------
firm_raise_bgmap_addr:
 mov  dptr,IO_OSD_bgmap_addr_lsb;\
 movx a,[dptr]                  ;
 inc  a                         ;
 movx [dptr],a                  ;/
 jnz  a,@@keep_msb
 mov  dptr,IO_OSD_bgmap_addr_msb;\
 movx a,[dptr]                  ;
 inc  a                         ;
 movx [dptr],a                  ;/
@@keep_msb:
 ret
;------------------
sysgui_make_font:
;mov  dptr,IO_OSD_char_xsiz          // mov a,12    // movx [dptr],a
;mov  dptr,IO_OSD_char_ysiz          // mov a,12    // movx [dptr],a
        .if smallfont
 mov  dptr,IO_OSD_char_xsiz          // mov a,8     // movx [dptr],a
 mov  dptr,IO_OSD_char_ysiz          // mov a,9     // movx [dptr],a
        .endif
 clr  a                         ;\
 mov  dptr,IO_OSD_font_addr_lsb ;
 movx [dptr],a                  ;
 mov  dptr,IO_OSD_font_addr_msb ;
 movx [dptr],a                  ;/
 mov  dptr,osd_charset
 mov  r0,40h
@@lop:
 push r0(0)
 call sysgui_make_char
 pop  r0(0)
 djnz r0,@@lop
;- - -
 mov  a,0000b
 call sysgui_make_bar
 mov  a,0001b
 call sysgui_make_bar
 mov  a,0011b
 call sysgui_make_bar
 mov  a,0111b
 call sysgui_make_bar
 mov  a,1111b
 call sysgui_make_bar
 mov  a,00000001b
 call sysgui_make_edge
 mov  a,10000000b
 call sysgui_make_edge
 ret
;------------------
sysgui_make_edge:
 mov  r1,a
 mov  r2,9
@@edge_ylop:
 mov  r0,r1(0)
 mov  r3,2
@@edge_xlop:
 call @@get_byte
 mov  dptr,IO_OSD_font_data_msb ;\
 movx [dptr],a                  ;/
 call @@get_byte
 mov  dptr,IO_OSD_font_data_lsb ;\
 movx [dptr],a                  ;/
 push a
 call firm_raise_font_addr
 pop  a
 djnz r3,@@edge_xlop
 djnz r2,@@edge_ylop
 ret
;---
@@get_byte:
 mov  a,r0
 rol  a
 rol  a
 mov  r0,a
 and  a,03h
 add  a,0eh
 and  a,11h
 ret
;------------------
sysgui_make_bar:
 mov  r1,a
 call @@make_black_line
 mov  r2,9-2
@@bar_ylop:
 mov  r0,r1(0)
 mov  r3,2
@@bar_xlop:
 call @@get_byte
 mov  dptr,IO_OSD_font_data_msb ;\
 movx [dptr],a                  ;/
 call @@get_byte
 mov  dptr,IO_OSD_font_data_lsb ;\
 movx [dptr],a                  ;/
 push a
 call firm_raise_font_addr
 pop  a
 djnz r3,@@bar_xlop
 djnz r2,@@bar_ylop
 call @@make_black_line
 ret
;---
@@make_black_line:
 mov  a,11h  ;black
 mov  dptr,IO_OSD_font_data_msb ;\
 movx [dptr],a                  ;/
 mov  dptr,IO_OSD_font_data_lsb ;\
 movx [dptr],a                  ;/
 call firm_raise_font_addr
 mov  a,11h  ;black
 mov  dptr,IO_OSD_font_data_lsb ;\
 movx [dptr],a                  ;/
 call firm_raise_font_addr
 ret
;---
@@get_byte:
 mov  a,r0
 rcr  a
 mov  r0,a
 mov  a,22h
 jc   @@this
 mov  a,33h
@@this:
 ret
;------------------
sysgui_make_char:  ;in: dptr=src, [IO_OSD_font_addr]=dst
 mov  r1,00h ;prev
 mov  r2,00h ;curr
 mov  r6,12-2  ;lopcount.y
        .if smallfont
        mov r6,9-2
        .endif
@@ylop:
 clr  a
 movc a,[a+dptr]
 inc  dptr
 push a      ;next
 push r2(0)  ;curr
 push dpl
 push dph
 call @@draw_row
 pop  dph
 pop  dpl
 pop  r1(0)  ;prev=curr
 pop  r2(0)  ;curr=next
 djnz r6,@@ylop
 clr  a      ;next
 push dpl
 push dph
 push r2(0)  ;curr
 call @@draw_row
 pop  r1(0)  ;prev=curr
 clr  a      ;next
 mov  r2,a   ;curr
 call @@draw_row
 pop  dph
 pop  dpl
 ret
;---
@@draw_row:
 or   a,r2   ;curr
 or   a,r1   ;prev
push a
clr c
rcr a
 mov  r1,a   ;merged
 mov  r7,12/4  ;lopcount.x
        .if smallfont
        mov r7,8/4
        .endif
 clr  c     ;msb of c:r1 (black)
 mov  f0,c  ;msb of f:r2 (color)

 mov  a,00h ;initially transp   ;\
 call @@getpix                  ;
xchg a,r1
pop a
clr c
xchg r1,a
 sjmp @@xlop_inj



@@xlop:
 mov  a,00h ;initially transp   ;\
 call @@getpix                  ;
@@xlop_inj:
 swap a                         ;
 call @@getpix                  ;
 mov  dptr,IO_OSD_font_data_msb ;
 movx [dptr],a                  ;/
 mov  a,00h ;initially transp   ;\
 call @@getpix                  ;
 swap a                         ;
 call @@getpix                  ;
 mov  dptr,IO_OSD_font_data_lsb ;
 movx [dptr],a                  ;/
 mov  dptr,IO_OSD_font_addr_lsb ;\
 movx a,[dptr]                  ;
 inc  a                         ;
 movx [dptr],a                  ;
 jnz  a,@@keep_addr_msb         ; raise font addr
 mov  dptr,IO_OSD_font_addr_msb ;
 movx a,[dptr]                  ;
 inc  a                         ;
 movx [dptr],a                  ;
@@keep_addr_msb:                ;/
 djnz r7,@@xlop
 ret
;--- --- ---
@@getpix:
 mov  b,r1        ;\
 or   c,b.7       ; test upper
 or   c,b.6       ; 3bit c:r1
 jnc  @@transp    ;/
 jz   f0,@@black  ;-text f:r2
@@color:
 inc  a      ;color
@@black:
 inc  a      ;black
@@transp:
 xchg a,r2      ;\
 add  a,a       ; next f:r2
 mov  f0,c      ;
 xchg a,r2      ;/
 xchg a,r1      ;\
 add  a,a       ; next c:r1
 xchg a,r1      ;/
 ret
;------------------
osd_charset:    ;font
.errif 0 <> 
.errif 1 <> 
;---
     .comment   ;experimental for smallfont=0
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     ;---
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     ;---
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     ;---
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     db 
     .comment
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db   ;
db   ;
db   ;
db   ;
db   ;
db   ;
db   ;
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 
;---
db 
db 
db 
db 
db 
db 
db 



;------------------
;:----------------- Settings (and free memory)
;------------------
; deff 0E000h-$   ;unused (FFh-filled)
;    db 0aah  ;dummy for mem_mirror_check
; deff 0F000h-$   ;unused (FFh-filled)
;    db 0aah  ;dummy for mem_mirror_check
;------------------
;deff 30000h     ;unused (FFh-filled)
;------------------
end
;------------------
;:---***-***------- End of All
;------------------
 XXXX @@prompt_panel_type: when MENU pushed: accept only if it's KEPT HELD down for 1 second or so
 XXXX @@prompt_panel_type: should ensure enough ADC irq's before getkey (seems to be enough time as is though)
 XXXX web: add no$x51 to main page

